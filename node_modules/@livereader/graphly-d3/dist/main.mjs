var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
import * as d3 from "d3";
import Ajv from "ajv";
function prerender(shape, onElement) {
  if (!document.getElementById("PRERENDER_SVG")) {
    let el = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    el.setAttribute("id", "PRERENDER_SVG");
    el.setAttribute("pointer-events", "none");
    el.setAttribute("width", "0");
    el.setAttribute("height", "0");
    el.setAttribute("style", "opacity: 0; position: absolute; top: 0; left: 0; width: 0; height: 0;");
    document.body.appendChild(el);
  }
  let svg = document.getElementById("PRERENDER_SVG");
  svg.innerHTML = shape.html();
  onElement(svg.children[0]);
  svg.innerHTML = "";
}
function getBBox(shape) {
  let bbox = {
    x: 0,
    y: 0,
    width: 0,
    height: 0
  };
  prerender(shape, (el) => {
    bbox = el.getBBox();
  });
  return bbox;
}
function create(type) {
  return d3.select(document.createElementNS("http://www.w3.org/2000/svg", type));
}
function transform$1(shape, size) {
  const bbox = getBBox(shape);
  const scale = size / Math.max(bbox.width, bbox.height);
  const translate = {
    x: -bbox.width * scale / 2 || 0,
    y: -bbox.height * scale / 2 || 0
  };
  shape.attr("transform", `translate(${translate.x}, ${translate.y}) scale(${scale || 1})`);
  return {
    scale,
    translate
  };
}
function Circle(radius) {
  const shape = create("g");
  const circle = create("circle");
  circle.attr("r", radius);
  circle.attr("transform", `translate(${radius}, ${radius})`);
  shape.append(() => circle.node());
  return shape;
}
function Rectangle(width, height, cr = 0) {
  const shape = create("g");
  const rect = create("path");
  rect.attr(
    "d",
    `M ${0} ${-(height / 2)} L ${width / 2 - cr} ${-(height / 2)} A ${cr} ${cr} 0 0 1 ${width / 2} ${-(height / 2) + cr} L ${width / 2} ${height / 2 - cr} A ${cr} ${cr} 0 0 1 ${width / 2 - cr} ${height / 2} L ${-(width / 2) + cr} ${height / 2} A ${cr} ${cr} 0 0 1 ${-(width / 2)} ${height / 2 - cr} L ${-(width / 2)} ${-(height / 2) + cr} A ${cr} ${cr} 0 0 1 ${-(width / 2) + cr} ${-(height / 2)} Z`
  );
  rect.attr("transform", `translate(${width / 2}, ${height / 2})`);
  shape.append(() => rect.node());
  return shape;
}
function Polygon(n, radius, curveRadius = 0) {
  const shape = Circle(radius);
  shape.select("circle").attr("fill", "none");
  shape.select("circle").attr("stroke", "none");
  const path = create("path");
  const points = [];
  for (let i = 0; i < n; i++) {
    const angle = i / n * 2 * Math.PI - Math.PI / 2;
    const x = Math.cos(angle) * radius;
    const y = Math.sin(angle) * radius;
    points.push({ x, y });
  }
  path.attr("d", roundedPath(points, curveRadius));
  path.attr("transform", `translate(${radius}, ${radius})`);
  shape.append(() => path.node());
  return shape;
}
function roundedPath(points, radius) {
  const path = [];
  points = points.slice();
  for (let i = 0; i < points.length; i++) {
    const c2i = i + 1 > points.length - 1 ? (i + 1) % points.length : i + 1;
    const c3i = i + 2 > points.length - 1 ? (i + 2) % points.length : i + 2;
    const c1 = points[i];
    const c2 = points[c2i];
    const c3 = points[c3i];
    const c1c2Dist = Math.sqrt(Math.pow(c1.x - c2.x, 2) + Math.pow(c1.y - c2.y, 2));
    const c1c2DistRadio = (c1c2Dist - radius) / c1c2Dist;
    const c1c2CurvePoint = [
      ((1 - c1c2DistRadio) * c1.x + c1c2DistRadio * c2.x).toFixed(1),
      ((1 - c1c2DistRadio) * c1.y + c1c2DistRadio * c2.y).toFixed(1)
    ];
    const c2c3Dist = Math.sqrt(Math.pow(c2.x - c3.x, 2) + Math.pow(c2.y - c3.y, 2));
    const c2c3DistRatio = radius / c2c3Dist;
    const c2c3CurvePoint = [
      ((1 - c2c3DistRatio) * c2.x + c2c3DistRatio * c3.x).toFixed(1),
      ((1 - c2c3DistRatio) * c2.y + c2c3DistRatio * c3.y).toFixed(1)
    ];
    if (i === points.length - 1) {
      path.unshift("M" + c2c3CurvePoint.join(","));
    }
    path.push("L" + c1c2CurvePoint.join(","));
    path.push("Q" + c2.x + "," + c2.y + "," + c2c3CurvePoint.join(","));
  }
  path.push("Z");
  return path.join(" ");
}
const Shape = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Circle,
  Polygon,
  Rectangle,
  create,
  getBBox,
  prerender,
  transform: transform$1
}, Symbol.toStringTag, { value: "Module" }));
const shapeStyles = "";
function ThemeStyle(data, lightValue, darkValue) {
  return {
    data,
    lightValue,
    darkValue
  };
}
function ShapeStyle(key, value, condition) {
  return {
    key,
    value,
    condition: condition ?? true
  };
}
function LODStyle(shape, key, value, condition) {
  return {
    shape,
    key,
    value,
    condition: condition ?? true
  };
}
function applyStyles(shape, styles) {
  styles.forEach((style) => {
    var _a;
    if (style.value instanceof Object) {
      applyStyle(
        shape,
        style.key,
        ((_a = style.value.data.renderConfig) == null ? void 0 : _a.theme) ?? true ? style.value.lightValue : style.value.darkValue,
        style.condition
      );
      if (!style.value.data.forceSimulation)
        return;
      style.value.data.forceSimulation.on(Event.ThemeChange, (theme) => {
        if (typeof style.value === "string")
          return;
        if (theme == "light")
          applyStyle(shape, style.key, style.value.lightValue, style.condition);
        else if (theme == "dark")
          applyStyle(shape, style.key, style.value.darkValue, style.condition);
      });
    } else {
      applyStyle(shape, style.key, style.value, style.condition);
    }
  });
}
function applyStyle(shape, key, value, condition) {
  if (key === "class") {
    value.split(".").forEach((value2) => {
      shape.classed(value2, typeof condition === "function" ? condition() : condition);
    });
  }
  if (typeof condition === "function" ? condition() : condition) {
    shape.style(key, value);
  }
}
function applyLODStyles(k, styles) {
  styles.forEach((style) => {
    if (style.key === "class") {
      style.value.split(".").forEach((value) => {
        style.shape.classed(
          value,
          typeof style.condition === "function" ? style.condition(k) : style.condition
        );
      });
    }
    if (typeof style.condition === "function" ? style.condition(k) : style.condition) {
      style.shape.style(style.key, style.value);
    }
  });
}
function PathShape(path) {
  const shape = create("path");
  shape.attr("d", path);
  return shape;
}
function SVGShape(code) {
  const shape = create("g");
  shape.html(code);
  return shape;
}
function TagStyle(padding, textStyles = [], backgroundStyles = [], cornerRadius = 0) {
  let p = {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  };
  if (typeof padding === "number") {
    p = { top: padding, right: padding, bottom: padding, left: padding };
  } else if (Array.isArray(padding) && padding.length === 2) {
    p = { top: padding[0], right: padding[1], bottom: padding[0], left: padding[1] };
  } else if (Array.isArray(padding) && padding.length === 4) {
    p = { top: padding[0], right: padding[1], bottom: padding[2], left: padding[3] };
  }
  return {
    padding: p,
    textStyles,
    backgroundStyles,
    cornerRadius
  };
}
function TagShape(text, style) {
  const shape = create("g").classed("tag", true);
  const textShape = shape.append("text").text(text).attr("dy", "0.35em").attr("text-anchor", "middle");
  applyStyles(textShape, style.textStyles);
  const textBBox = getBBox(shape);
  const width = textBBox.width;
  const height = textBBox.height;
  const pt = style.padding.top;
  const pr = style.padding.right;
  const pb = style.padding.bottom;
  const pl = style.padding.left;
  const cr = style.cornerRadius;
  const backgroundShape = shape.append("path").attr(
    "d",
    `M ${0} ${-(height / 2) - pt} L ${width / 2 + pr - cr} ${-(height / 2) - pt} A ${cr} ${cr} 0 0 1 ${width / 2 + pr} ${-(height / 2) - pt + cr} L ${width / 2 + pr} ${height / 2 + pb - cr} A ${cr} ${cr} 0 0 1 ${width / 2 + pr - cr} ${height / 2 + pb} L ${-(width / 2) - pl + cr} ${height / 2 + pb} A ${cr} ${cr} 0 0 1 ${-(width / 2) - pl} ${height / 2 + pb - cr} L ${-(width / 2) - pl} ${-(height / 2) - pt + cr} A ${cr} ${cr} 0 0 1 ${-(width / 2) - pl + cr} ${-(height / 2) - pt} Z`
  );
  applyStyles(backgroundShape, style.backgroundStyles);
  textShape.remove();
  shape.append(() => textShape.node());
  return shape;
}
function TextShape(text, styles = []) {
  const shape = create("g").classed("text", true);
  const textShape = shape.append("text").text(text);
  applyStyles(textShape, styles);
  shape.attr("text-anchor", "middle");
  return shape;
}
function BreakLine() {
  return "break-line";
}
var Alignment = /* @__PURE__ */ ((Alignment2) => {
  Alignment2["Left"] = "left";
  Alignment2["Center"] = "center";
  Alignment2["Right"] = "right";
  return Alignment2;
})(Alignment || {});
function CollectionStyle(height, width, x, y, dx2, dy2, rowCount, align = "center", rowMargins = []) {
  return {
    height,
    width,
    x,
    y,
    dx: dx2,
    dy: dy2,
    rowCount,
    align,
    rowMargins
  };
}
function ShapeCollection(shapes, style, ellipsis = null) {
  const collection = create("g").classed("collection", true).attr("transform", `translate(${style.x}, ${style.y})`);
  assamble(shapes, style, ellipsis, collection);
  return collection;
}
function assamble(shapes, style, ellipsis = null, collection) {
  const rowHeight = (style.height - style.dy * (style.rowCount - 1)) / style.rowCount;
  let shapeIndex = 0;
  let skippedShapes = [];
  for (let i = 0; i < style.rowCount; i++) {
    if (shapeIndex > shapes.length - 1)
      return;
    const rowMargin = style.rowMargins[i] || 0;
    const rowWidth = style.width - rowMargin * 2;
    const row = collection.append("g").attr("id", `row-${i}`).attr("transform", `translate(${rowMargin}, ${(rowHeight + style.dy) * i})`);
    shapeIndex = assambleRow(
      shapes,
      style,
      ellipsis,
      row,
      rowWidth,
      shapeIndex,
      skippedShapes,
      i == style.rowCount - 1
    );
  }
}
function assambleRow(shapes, style, ellipsis = null, row, width, shapeIndex, skippedShapes, isLastRow) {
  const items = [];
  let widthSum = 0;
  let index = shapeIndex;
  while (widthSum < width && index < shapes.length) {
    const shape = shapes[index];
    if (!shape)
      break;
    if (typeof shape === "string") {
      index++;
      break;
    }
    if (typeof shape === "string")
      break;
    const itemWidth = getBBox(shape).width;
    if (itemWidth > width) {
      skippedShapes.push(shape);
      index++;
      continue;
    }
    if (widthSum + itemWidth < width) {
      items.push(shape);
      widthSum += itemWidth + style.dx;
      index++;
    } else {
      if (isLastRow) {
        skippedShapes.push(shape);
      }
      break;
    }
  }
  if (ellipsis && skippedShapes.length > 0 && (index >= shapes.length || isLastRow)) {
    items.push(ellipsis);
    widthSum += getBBox(ellipsis).width + style.dx;
  }
  widthSum -= style.dx;
  let comulatedWidth = 0;
  items.forEach((item) => {
    const itemWidth = getBBox(item).width;
    let pos = 0;
    switch (style.align) {
      case "left":
        pos = comulatedWidth + itemWidth / 2;
        break;
      case "center":
        pos = comulatedWidth + itemWidth / 2 + (width - widthSum) / 2;
        break;
      case "right":
        pos = comulatedWidth + itemWidth / 2 + (width - widthSum);
        break;
    }
    item.attr("transform", `translate(${pos}, 0)`);
    row.append(() => item.node());
    comulatedWidth += itemWidth + style.dx;
  });
  return index;
}
function TextCollection(text, style, textStyles = []) {
  const textShapes = [];
  const words = text.split(" ");
  words.forEach((word) => {
    if (word.includes("\n")) {
      const lines = word.split("\n");
      lines.forEach((line2) => {
        textShapes.push(TextShape(line2, textStyles));
        textShapes.push(BreakLine());
      });
      textShapes.pop();
    } else {
      textShapes.push(TextShape(word, textStyles));
    }
  });
  const ellipsis = TextShape("...", textStyles);
  const collection = ShapeCollection(textShapes, style, ellipsis);
  return collection;
}
function TagCollection(tags, style, tagStyle) {
  const tagShapes = [];
  tags.forEach((tag) => {
    const tagShape = TagShape(tag, tagStyle);
    tagShapes.push(tagShape);
  });
  const ellipsis = TagShape("...", tagStyle);
  const collection = ShapeCollection(tagShapes, style, ellipsis);
  return collection;
}
function OnZoom(data, threshold, styles = []) {
  if (Array.isArray(threshold)) {
    threshold.forEach((t) => register(data, t, styles));
  } else {
    register(data, threshold, styles);
  }
}
function register(data, threshold, styles = []) {
  const id = `${data.id}-${threshold}`;
  const globalThreshold = threshold / (isNaN(data.shape.scale) ? 1 : data.shape.scale);
  const callback = (k) => {
    const relativeScale = k * (isNaN(data.shape.scale) ? 1 : data.shape.scale);
    applyLODStyles(relativeScale, styles);
    return true;
  };
  if (data.renderConfig)
    callback(data.renderConfig.scale);
  if (data.forceSimulation && data.forceSimulation.registerOnZoom)
    data.forceSimulation.registerOnZoom(id, globalThreshold, callback);
}
function OnThemeChange(data, callback) {
  var _a;
  callback(((_a = data.renderConfig) == null ? void 0 : _a.theme) ?? "light");
  if (!data.forceSimulation)
    return;
  data.forceSimulation.eventStore.on("theme:change", callback);
}
function brightness(color) {
  if (!color)
    return -1;
  const isHEX = color.indexOf("#") == 0;
  const isRGB = color.indexOf("rgb") == 0;
  if (isHEX) {
    const hasFullHex = color.length == 7;
    const r = hasFullHex ? parseInt(color.substring(1, 3), 16) : parseInt(color.substring(1, 2), 16);
    const g = hasFullHex ? parseInt(color.substring(3, 5), 16) : parseInt(color.substring(2, 3), 16);
    const b = hasFullHex ? parseInt(color.substring(5, 7), 16) : parseInt(color.substring(3, 4), 16);
    return (r * 299 + g * 587 + b * 114) / 1e3 / 255;
  } else if (isRGB) {
    const rgb = color.match(/\d+/g);
    if (!rgb || rgb.length < 3)
      return -1;
    const r = parseInt(rgb[0]);
    const g = parseInt(rgb[1]);
    const b = parseInt(rgb[2]);
    return (r * 299 + g * 587 + b * 114) / 1e3 / 255;
  }
  return -1;
}
function isLight(color) {
  return brightness(color) > 0.5;
}
function isDark(color) {
  return brightness(color) < 0.5 && brightness(color) >= 0;
}
function EmitEvent(identifier, data, event, ...args) {
  if (!data.forceSimulation)
    return;
  data.forceSimulation.eventStore.emit(`template:${data.shape.type}:${identifier}`, data, event, ...args);
}
const TemplateAPI = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Alignment,
  BreakLine,
  CollectionStyle,
  EmitEvent,
  LODStyle,
  OnThemeChange,
  OnZoom,
  PathShape,
  SVGShape,
  Shape,
  ShapeCollection,
  ShapeStyle,
  TagCollection,
  TagShape,
  TagStyle,
  TextCollection,
  TextShape,
  ThemeStyle,
  applyLODStyles,
  applyStyles,
  brightness,
  isDark,
  isLight
}, Symbol.toStringTag, { value: "Module" }));
const ErrorTemplate = {
  shapeSize: 200,
  shapeBuilder
};
function shapeBuilder(data) {
  const shape = create("g");
  const { icon_large } = addBody(shape);
  icon_large.classed("hidden", true);
  addTitle(shape);
  addDescription(data, shape);
  return shape;
}
function addBody(shape) {
  const body = SVGShape(`
		<g>
			<path id="border" d="M8.373,392.094c-11.164,-19.338 -11.164,-43.163 0,-62.5c39.417,-68.271 132.833,-230.073 172.249,-298.344c11.165,-19.338 31.798,-31.25 54.127,-31.25l344.498,0c22.329,-0 42.962,11.912 54.126,31.25c39.417,68.271 132.833,230.073 172.249,298.344c11.165,19.337 11.165,43.162 0,62.5c-39.416,68.271 -132.832,230.073 -172.249,298.344c-11.164,19.337 -31.797,31.25 -54.126,31.25l-344.498,-0c-22.329,-0 -42.962,-11.913 -54.127,-31.25c-39.416,-68.271 -132.832,-230.073 -172.249,-298.344Zm41.667,-0c-11.164,-19.338 -11.164,-43.163 0,-62.5c35.831,-62.06 115.585,-200.199 151.416,-262.26c11.164,-19.337 31.797,-31.25 54.126,-31.25l302.831,0c22.33,0 42.963,11.913 54.127,31.25c35.831,62.061 115.585,200.2 151.416,262.26c11.164,19.337 11.164,43.162 -0,62.5c-35.831,62.06 -115.585,200.199 -151.416,262.259c-11.164,19.338 -31.797,31.25 -54.127,31.25l-302.831,0c-22.329,0 -42.962,-11.912 -54.126,-31.25c-35.831,-62.06 -115.585,-200.199 -151.416,-262.259Z" style="fill:#e57373;" />
			<path id="body" d="M50.04,392.094c-11.164,-19.338 -11.164,-43.163 0,-62.5c35.831,-62.06 115.585,-200.199 151.416,-262.26c11.164,-19.337 31.797,-31.25 54.126,-31.25l302.831,0c22.33,0 42.963,11.913 54.127,31.25c35.831,62.061 115.585,200.2 151.416,262.26c11.164,19.337 11.164,43.162 -0,62.5c-35.831,62.06 -115.585,200.199 -151.416,262.259c-11.164,19.338 -31.797,31.25 -54.127,31.25l-302.831,0c-22.329,0 -42.962,-11.912 -54.126,-31.25c-35.831,-62.06 -115.585,-200.199 -151.416,-262.259Z" />
			<path id="icon" d="M392.598,301.417c-0,7.953 6.447,14.4 14.4,14.4c0.003,-0 0.005,-0 0.008,-0c3.817,-0 7.478,-1.516 10.177,-4.215c2.699,-2.699 4.215,-6.36 4.215,-10.177c-0,-1.135 -0,-2.281 -0,-3.416c-0,-3.817 -1.516,-7.478 -4.215,-10.177c-2.699,-2.699 -6.36,-4.215 -10.177,-4.215c-0.003,-0 -0.005,-0 -0.008,-0c-7.953,-0 -14.4,6.447 -14.4,14.4c-0,1.129 -0,2.27 -0,3.4Zm2.242,-47.423c0.2,6.587 5.597,11.823 12.187,11.823c0.003,-0 0.007,-0 0.01,-0c6.556,-0 11.93,-5.202 12.144,-11.755c0.506,-15.54 1.397,-42.915 1.944,-59.729c0.124,-3.806 -1.301,-7.499 -3.949,-10.235c-2.649,-2.736 -6.294,-4.281 -10.102,-4.281c-0.004,-0 -0.008,-0 -0.012,-0c-3.795,-0 -7.429,1.537 -10.072,4.261c-2.643,2.724 -4.07,6.403 -3.955,10.196c0.507,16.785 1.335,44.149 1.805,59.72Z" style="fill:#e57373;fill-rule:nonzero;" />
			<path id="icon_large" d="M371.559,477.859c-0,19.491 15.8,35.291 35.291,35.291c0.002,0 0.004,0 0.005,0c19.491,0 35.292,-15.8 35.292,-35.291c-0,-2.771 -0,-5.568 -0,-8.339c-0,-19.491 -15.801,-35.291 -35.292,-35.291c-0.001,-0 -0.003,-0 -0.005,-0c-19.491,-0 -35.291,15.8 -35.291,35.291c-0,2.771 -0,5.568 -0,8.339Zm5.494,-116.303c0.489,16.181 13.748,29.045 29.936,29.045l0.012,0c16.041,0 29.188,-12.726 29.71,-28.758c1.239,-38.08 3.425,-105.217 4.768,-146.446c0.303,-9.329 -3.19,-18.381 -9.681,-25.088c-6.492,-6.706 -15.426,-10.492 -24.759,-10.492c-0.003,-0 -0.005,-0 -0.007,-0c-9.309,-0 -18.22,3.77 -24.702,10.451c-6.481,6.68 -9.981,15.702 -9.699,25.006c1.243,41.116 3.268,108.114 4.422,146.282Z" style="fill:#e57373;fill-rule:nonzero;" />
		</g>
	`);
  shape.append(() => body.node());
  shape.classed("gly_animated", true);
  return {
    border: body.select("#border"),
    body: body.select("#body"),
    icon: body.select("#icon"),
    icon_large: body.select("#icon_large")
  };
}
function addTitle(shape) {
  const bbox = getBBox(shape);
  const title = TextCollection("Template Error", CollectionStyle(100, bbox.width, 0, 140, 20, 20, 1), [
    ShapeStyle("class", "gly_text.dark"),
    ShapeStyle("font-weight", "bold"),
    ShapeStyle("font-size", "44pt")
  ]);
  shape.append(() => title.node());
  return title;
}
function addDescription(data, shape) {
  const bbox = getBBox(shape);
  const description = TextCollection(
    (data == null ? void 0 : data.errorMessage) ?? "Something went wrong while rendering the template!",
    CollectionStyle(250, bbox.width, 0, bbox.height * 0.6, 15, 20, 4, Alignment.Center, [80, 130, 180, 230]),
    [ShapeStyle("class", "gly_text.dark"), ShapeStyle("font-size", "32pt")]
  );
  shape.append(() => description.node());
  return description;
}
class TemplateStore {
  constructor() {
    __publicField(this, "_errorTemplate", ErrorTemplate);
    __publicField(this, "_templates", {});
    __publicField(this, "failed", []);
    __publicField(this, "remoteOrigin", "");
  }
  get errorTemplate() {
    return this._errorTemplate;
  }
  get templates() {
    return this._templates;
  }
  add(id, template) {
    this._templates[id] = template;
  }
  async get(node) {
    const id = node.shape.type;
    if (this.templates[id])
      return this.templates[id];
    if (this.failed.includes(id))
      return this.errorTemplate;
    const template = await this.load(node.shape.url ?? this.remoteOrigin + id + ".js", id).then(() => {
      if (this.templates[id])
        return this.templates[id];
      return void 0;
    });
    return template;
  }
  async load(url, id) {
    if (this.failed.includes(id))
      return;
    if (origin == "")
      return;
    await import(
      /* webpackIgnore: true */
      /* @vite-ignore */
      url
    ).then(({ default: template }) => {
      this.add(id, template);
    }).catch((error) => {
      console.error(
        `[graphly-d3] Template "${id}" not found - Fetched from "${url}"

Failed with error:
${error} 

Troubleshooting: https://docs.graphly.dev/troubleshooting/`
      );
      this.failed.push(id);
    }).finally(() => {
    });
  }
}
class NodeDataStore {
  constructor() {
    __publicField(this, "nodes", {});
  }
  clear() {
    this.nodes = {};
  }
  add(id, node) {
    this.nodes[id] = this.storeNode(node);
  }
  remove(id) {
    delete this.nodes[id];
  }
  hasNode(id) {
    return this.nodes[id] !== void 0;
  }
  hasTemplateChange(id, data) {
    const node = this.nodes[id];
    if (node === void 0)
      return false;
    return node.shape.type !== data.shape.type || node.shape.template !== data.shape.template;
  }
  hasPayloadChanges(id, data) {
    const node = this.nodes[id];
    if (!node)
      return true;
    return JSON.stringify(node.payload ?? "") !== JSON.stringify(data.payload ?? "");
  }
  storeNode(node) {
    const copy = {
      shape: {
        type: Object.assign({}, node.shape).type,
        template: Object.assign({}, node.shape).template
      },
      payload: node.payload ? this.deepCopy(node.payload) : void 0
    };
    return copy;
  }
  deepCopy(instance) {
    if (instance == null) {
      return instance;
    }
    if (instance instanceof Array) {
      var cloneArray = [];
      instance.forEach((value) => {
        cloneArray.push(value);
      });
      return cloneArray.map((value) => this.deepCopy(value));
    }
    if (instance instanceof Object) {
      var copyInstance = { ...instance };
      for (var attr in instance) {
        if (instance.hasOwnProperty(attr))
          copyInstance[attr] = this.deepCopy(instance[attr]);
      }
      return copyInstance;
    }
    return instance;
  }
}
var AnchorType = /* @__PURE__ */ ((AnchorType2) => {
  AnchorType2["Soft"] = "soft";
  AnchorType2["Hard"] = "hard";
  return AnchorType2;
})(AnchorType || {});
var SatelliteType = /* @__PURE__ */ ((SatelliteType2) => {
  SatelliteType2["Soft"] = "soft";
  SatelliteType2["Hard"] = "hard";
  return SatelliteType2;
})(SatelliteType || {});
var LinkType = /* @__PURE__ */ ((LinkType2) => {
  LinkType2["Solid"] = "solid";
  LinkType2["Dashed"] = "dashed";
  LinkType2["Dotted"] = "dotted";
  LinkType2["Hidden"] = "hidden";
  return LinkType2;
})(LinkType || {});
var ArrowDirection = /* @__PURE__ */ ((ArrowDirection2) => {
  ArrowDirection2["Head"] = "head";
  ArrowDirection2["Tail"] = "tail";
  ArrowDirection2["Both"] = "both";
  return ArrowDirection2;
})(ArrowDirection || {});
var LinkStrength = /* @__PURE__ */ ((LinkStrength2) => {
  LinkStrength2["Strong"] = "strong";
  LinkStrength2["Weak"] = "weak";
  LinkStrength2["Loose"] = "loose";
  return LinkStrength2;
})(LinkStrength || {});
const ajv = new Ajv({ allErrors: true });
function renderTemplate(template, data, config) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i;
  if (!template)
    return throwError(`[graphly-d3] No "${((_a = data.shape) == null ? void 0 : _a.type) ?? ""}" template provided!`);
  if (!data)
    return Promise.reject(`[graphly-d3] No data provided!`);
  if (!config)
    return Promise.reject(`[graphly-d3] No config provided!`);
  data.renderConfig = config;
  const nodeShape = create("g");
  nodeShape.classed("gly-node", true).attr("data-id", data.id);
  if (!template.shapePayload) {
    console.warn(
      `[graphly-d3] Template ${((_b = data.shape) == null ? void 0 : _b.type) ? '"' + data.shape.type + '"' : ""} has no payload schema defined! 

If you are the author of this template, you can find more details here: https://docs.graphly.dev/template-api/shape_payload`
    );
  } else {
    const validate = ajv.compile(template.shapePayload);
    const isValid = validate(data.payload);
    if (!isValid) {
      console.error(
        `[graphly-d3] Invalid payload for template ${((_c = data.shape) == null ? void 0 : _c.type) ? '"' + data.shape.type + '"' : ""}
 • ${(_d = validate.errors) == null ? void 0 : _d.map((e) => `${e.instancePath} ${e.message}`).join("\n • ")} 

Troubleshooting: https://docs.graphly.dev/troubleshooting/`
      );
      return throwError(
        `"${((_e = data.shape) == null ? void 0 : _e.type) ?? ""}" ${(_f = validate.errors) == null ? void 0 : _f[0].instancePath} ${(_g = validate.errors) == null ? void 0 : _g[0].message}`,
        false
      );
    }
  }
  try {
    nodeShape.append(() => template.shapeBuilder(data, TemplateAPI).node()).attr("data-object", "shape");
  } catch (e) {
    console.error(
      `[graphly-d3] Template ${((_h = data.shape) == null ? void 0 : _h.type) ? '"' + data.shape.type + '"' : ""} failed rendering with error: 
${e} 

Troubleshooting: https://docs.graphly.dev/troubleshooting/`
    );
    return throwError(e.message);
  }
  const shapeSize = (template.shapeSize ?? 300) * data.shape.scale * config.scale;
  transform$1(nodeShape.select("[data-object=shape]"), shapeSize);
  const selection = nodeShape.node();
  if (selection === null)
    return throwError(
      `[graphly-d3] Template ${((_i = data.shape) == null ? void 0 : _i.type) ? '"' + data.shape.type + '"' : ""} failed rendering!`
    );
  return Promise.resolve(selection);
}
function throwError(message, log = true) {
  if (log)
    console.error(message);
  return Promise.reject(message);
}
function Node(data) {
  var _a;
  if (!data.forceSimulation) {
    data.shape.failed = true;
    return null;
  }
  const exists = data.forceSimulation.nodeDataStore.hasNode(data.id);
  let nodeShape = exists ? d3.select(this) : create("g");
  nodeShape.classed("gly-node", true).attr("data-id", data.id);
  const hasChanges = data.forceSimulation.nodeDataStore.hasPayloadChanges(data.id, data);
  const hasTemplateChange = data.forceSimulation.nodeDataStore.hasTemplateChange(data.id, data);
  data.forceSimulation.nodeDataStore.add(data.id, data);
  if (!hasChanges && !hasTemplateChange && !data.shape.failed) {
    transform$1(
      nodeShape.select("[data-object=shape]"),
      data.shape.scale * (((_a = data.shape.template) == null ? void 0 : _a.shapeSize) ?? 300)
    );
    return nodeShape.node();
  }
  nodeShape.selectAll("*").remove();
  if (!data.shape.template) {
    return throwError2(`Template "${data.shape.type}" not found!`);
  }
  renderTemplate(data.shape.template, data, {
    theme: data.forceSimulation.theme ?? "light",
    scale: data.forceSimulation.worldTransform.k ?? 1
  }).then((render) => {
    nodeShape.append(() => d3.select(render).select("[data-object=shape]").node()).attr("data-object", "shape");
    if (data.forceSimulation) {
      data.forceSimulation.onZoomRegister.filter((r) => r.id.startsWith(data.id)).forEach((r) => {
        if (!data.forceSimulation)
          return;
        r.callback(data.forceSimulation.worldTransform.k);
      });
    }
    data.shape.failed = false;
    buildGlyBody();
  }).catch((error) => {
    console.error(error);
    return throwError2(error);
  });
  return nodeShape.node();
  function buildGlyBody() {
    var _a2, _b;
    const bbox = getBBox(nodeShape);
    const shapeSize = data.shape.scale * (((_a2 = data.shape.template) == null ? void 0 : _a2.shapeSize) ?? 300);
    data.shape.bodyPoints = [];
    const glyBody = nodeShape.select(".gly-body").node();
    const points = [];
    if (glyBody && glyBody.getTotalLength) {
      let n = ((_b = data.shape) == null ? void 0 : _b.bodyResolution) || 32;
      const totalLength = glyBody.getTotalLength();
      for (let i = 0; i < n; i++) {
        const p = glyBody.getPointAtLength(i / n * totalLength);
        p.x = Math.round(p.x);
        p.y = Math.round(p.y);
        points.push(p);
      }
      const pointsXmin = Math.min(...points.map((p) => p.x));
      const pointsXmax = Math.max(...points.map((p) => p.x));
      const pointsYmin = Math.min(...points.map((p) => p.y));
      const pointsYmax = Math.max(...points.map((p) => p.y));
      const pointsWidth = pointsXmax - pointsXmin;
      const pointsHeight = pointsYmax - pointsYmin;
      const pointsScale = {
        x: bbox.width / pointsWidth,
        y: bbox.height / pointsHeight
      };
      points.forEach((p) => {
        var _a3, _b2;
        p.x = (p.x - pointsXmin) * pointsScale.x + bbox.x - pointsWidth * pointsScale.x / 2 + shapeSize;
        p.y = (p.y - pointsYmin) * pointsScale.y + bbox.y - pointsHeight * pointsScale.y / 2 + shapeSize;
        if (((_b2 = (_a3 = data.forceSimulation) == null ? void 0 : _a3.debug) == null ? void 0 : _b2.enabled) && data.forceSimulation.debug.bodyPoints.enabled) {
          nodeShape.select("[data-object=shape]").append("circle").classed("gly-body-points", true).attr("cx", p.x + pointsWidth * pointsScale.x / 2 - shapeSize).attr("cy", p.y + pointsHeight * pointsScale.y / 2 - shapeSize).attr("r", Math.max(bbox.height, bbox.width) / shapeSize * 5).attr("fill", data.forceSimulation.debug.bodyPoints.color).attr("stroke", "none");
        }
      });
      data.shape.bodyPoints = points;
    }
    const transform2 = transform$1(nodeShape.select("[data-object=shape]"), shapeSize);
    for (let p of points) {
      p.x = (p.x - shapeSize) * transform2.scale;
      p.y = (p.y - shapeSize) * transform2.scale;
    }
  }
  function throwError2(message) {
    var _a2, _b, _c;
    data.shape.failed = true;
    data.errorMessage = message;
    nodeShape.append(() => {
      if (!data.forceSimulation)
        return null;
      return data.forceSimulation.templateStore.errorTemplate.shapeBuilder.bind(this)(data, TemplateAPI).node();
    }).attr("data-object", "shape");
    transform$1(
      nodeShape.select("[data-object=shape]"),
      data.shape.scale * (((_c = (_b = (_a2 = data.forceSimulation) == null ? void 0 : _a2.templateStore) == null ? void 0 : _b.errorTemplate) == null ? void 0 : _c.shapeSize) ?? 300)
    );
    return nodeShape.node();
  }
}
var Event = /* @__PURE__ */ ((Event2) => {
  Event2["NodeClick"] = "node:click";
  Event2["NodeDoubleClick"] = "node:doubleclick";
  Event2["NodeContextMenu"] = "node:contextmenu";
  Event2["NodeDragStart"] = "node:dragstart";
  Event2["NodeDragMove"] = "node:dragmove";
  Event2["NodeDragEnd"] = "node:dragend";
  Event2["LinkClick"] = "link:click";
  Event2["LinkDoubleClick"] = "link:doubleclick";
  Event2["LinkContextMenu"] = "link:contextmenu";
  Event2["LinkDragStart"] = "link:dragstart";
  Event2["LinkDragMove"] = "link:dragmove";
  Event2["LinkDragEnd"] = "link:dragend";
  Event2["EnvironmentClick"] = "environment:click";
  Event2["EnvironmentDoubleClick"] = "environment:doubleclick";
  Event2["EnvironmentContextMenu"] = "environment:contextmenu";
  Event2["EnvironmentMove"] = "environment:move";
  Event2["ThemeChange"] = "theme:change";
  Event2["SimulationTick"] = "simulation:tick";
  Event2["SimulationTickEnd"] = "simulation:tickend";
  return Event2;
})(Event || {});
const Events = {
  [
    "node:click"
    /* NodeClick */
  ]: {
    event: (d) => d,
    node: (d) => d
  },
  [
    "node:doubleclick"
    /* NodeDoubleClick */
  ]: {
    event: (d) => d,
    node: (d) => d
  },
  [
    "node:contextmenu"
    /* NodeContextMenu */
  ]: {
    event: (d) => d,
    node: (d) => d
  },
  [
    "node:dragstart"
    /* NodeDragStart */
  ]: {
    event: (d) => d,
    node: (d) => d,
    pos: (x, y) => ({ x, y })
  },
  [
    "node:dragmove"
    /* NodeDragMove */
  ]: {
    event: (d) => d,
    node: (d) => d,
    pos: (x, y) => ({ x, y })
  },
  [
    "node:dragend"
    /* NodeDragEnd */
  ]: {
    event: (d) => d,
    node: (d) => d,
    pos: (x, y) => ({ x, y })
  },
  [
    "link:click"
    /* LinkClick */
  ]: {
    event: (d) => d,
    link: (d) => d
  },
  [
    "link:doubleclick"
    /* LinkDoubleClick */
  ]: {
    event: (d) => d,
    link: (d) => d
  },
  [
    "link:contextmenu"
    /* LinkContextMenu */
  ]: {
    event: (d) => d,
    link: (d) => d
  },
  [
    "link:dragstart"
    /* LinkDragStart */
  ]: {
    event: (d) => d,
    source: (d) => d,
    pos: (x, y) => ({ x, y })
  },
  [
    "link:dragmove"
    /* LinkDragMove */
  ]: {
    event: (d) => d,
    source: (d) => d,
    pos: (x, y) => ({ x, y })
  },
  [
    "link:dragend"
    /* LinkDragEnd */
  ]: {
    event: (d) => d,
    source: (d) => d,
    target: (d) => d,
    pos: (x, y) => ({ x, y })
  },
  [
    "environment:click"
    /* EnvironmentClick */
  ]: {
    event: (d) => d,
    pos: (x, y) => ({ x, y })
  },
  [
    "environment:doubleclick"
    /* EnvironmentDoubleClick */
  ]: {
    event: (d) => d,
    pos: (x, y) => ({ x, y })
  },
  [
    "environment:contextmenu"
    /* EnvironmentContextMenu */
  ]: {
    event: (d) => d,
    pos: (x, y) => ({ x, y })
  },
  [
    "environment:move"
    /* EnvironmentMove */
  ]: {
    pos: (t) => t
  },
  [
    "theme:change"
    /* ThemeChange */
  ]: {
    theme: (t) => t
  },
  [
    "simulation:tick"
    /* SimulationTick */
  ]: {},
  [
    "simulation:tickend"
    /* SimulationTickEnd */
  ]: {}
};
class EventStore {
  constructor() {
    __publicField(this, "register", {});
  }
  on(event, callback) {
    if (!this.register[event])
      this.register[event] = [];
    this.register[event].push({ [callback.name]: callback });
  }
  off(event, callback) {
    if (!this.register[event])
      return;
    this.register[event] = this.register[event].filter((c) => c[callback.name] !== callback);
  }
  emit(event, ...args) {
    if (!this.register[event])
      return [];
    const res = [];
    this.register[event].forEach((callback) => {
      for (const c in callback) {
        res.push(callback[c](...args));
      }
    });
    return res;
  }
}
__publicField(EventStore, "events", Events);
let newLinkDraging = false;
let newLink;
let dragOffset = { x: 0, y: 0 };
function dragNode() {
  return d3.drag().on("start", (e, d) => dragStart.bind(this)(e, d)).on("drag", (e, d) => dragMove.bind(this)(e, d)).on("end", (e, d) => dragEnd.bind(this)(e, d));
}
function dragStart(e, d) {
  const emitResponse = this.eventStore.emit(Event.NodeDragStart, e, d, { x: e.x, y: e.y });
  if (emitResponse.includes("newlink"))
    return dragNewLinkStart.bind(this)(e, d);
  if (!this.draggableNodes)
    return;
  this.simulation.alphaTarget(0.05).restart();
  d.isDraged = true;
  d.fx = e.x;
  d.fy = e.y;
}
function dragMove(e, d) {
  if (newLinkDraging)
    return dragNewLinkMove.bind(this)(e, d);
  if (!this.draggableNodes)
    return;
  d.fx = e.x;
  d.fy = e.y;
  this.eventStore.emit(Event.NodeDragMove, e, d, { x: e.x, y: e.y });
}
function dragEnd(e, d) {
  if (newLinkDraging)
    return dragNewLinkEnd.bind(this)(e, d);
  if (!this.draggableNodes)
    return dragNewLinkEnd.bind(this)(e, d);
  if (!this.draggableNodes)
    return;
  this.simulation.alphaTarget(0);
  d.isDraged = false;
  d.fx = null;
  d.fy = null;
  this.eventStore.emit(Event.NodeDragEnd, e, d, { x: e.x, y: e.y });
}
function dragNewLinkStart(e, d) {
  dragOffset = {
    x: e.sourceEvent.offsetX / this.worldTransform.k - this.worldTransform.x / this.worldTransform.k - (d.x ?? 0),
    y: e.sourceEvent.offsetY / this.worldTransform.k - this.worldTransform.y / this.worldTransform.k - (d.y ?? 0)
  };
  newLinkDraging = true;
  newLink = this.selectionGroups.links.append("g").attr("data-object", "prelink").classed("gly-prelink", true);
  newLink.append("line").attr("data-object", "prelink-link-line").classed("gly-link-line", true).attr("x1", d.x ?? 0).attr("y1", d.y ?? 0).attr("x2", e.x).attr("y2", e.y);
  this.eventStore.emit(Event.LinkDragStart, e, d, { x: e.x, y: e.y });
}
function dragNewLinkMove(e, d) {
  const mousePos = {
    x: e.x + dragOffset.x,
    y: e.y + dragOffset.y
  };
  newLink.select("[data-object='prelink-link-line']").attr("x2", mousePos.x).attr("y2", mousePos.y);
  this.eventStore.emit(Event.LinkDragMove, e, d, { x: e.x, y: e.y });
}
function dragNewLinkEnd(e, d) {
  newLink.remove();
  newLinkDraging = false;
  let target = e.sourceEvent.target;
  if (target == this.svgElement)
    return this.eventStore.emit(Event.LinkDragEnd, e, d, null, { x: e.x, y: e.y });
  while (target.attributes["data-object"] == null) {
    if (target == null)
      return this.eventStore.emit(Event.LinkDragEnd, e, d, null, { x: e.x, y: e.y });
    target = target.parentElement;
    if (!target)
      return this.eventStore.emit(Event.LinkDragEnd, e, d, null, { x: e.x, y: e.y });
  }
  target = target.parentElement;
  if (!target)
    return this.eventStore.emit(Event.LinkDragEnd, e, d, null, { x: e.x, y: e.y });
  const targetNode = this.graph.nodes.find((n) => {
    var _a;
    return n.id == ((_a = target.attributes["data-id"]) == null ? void 0 : _a.value);
  });
  if (!targetNode)
    return this.eventStore.emit(Event.LinkDragEnd, e, d, null, { x: e.x, y: e.y });
  if (targetNode.id == d.id)
    return this.eventStore.emit(Event.LinkDragEnd, e, d, null, { x: e.x, y: e.y });
  this.eventStore.emit(Event.LinkDragEnd, e, d, targetNode, { x: e.x, y: e.y });
}
function indexLinks(graph2) {
  graph2.links = graph2.links.filter((l) => {
    const source = typeof l.source === "string" ? graph2.nodes.find((n) => n.id === l.source) : graph2.nodes.find((n) => n.id === l.source.id);
    const target = typeof l.target === "string" ? graph2.nodes.find((n) => n.id === l.target) : graph2.nodes.find((n) => n.id === l.target.id);
    if (!source || !target)
      return false;
    return true;
  });
  graph2.nodes.forEach((node) => {
    const links = [];
    graph2.links.forEach((link) => {
      if (link.source == node.id || link.source.id == node.id) {
        links.push(link);
      }
    });
    const groupedLinks = {};
    links.forEach((link) => {
      if (typeof link.target == "object") {
        const targetID = typeof link.target === "string" ? link.target : link.target.id;
        if (!groupedLinks[targetID]) {
          groupedLinks[targetID] = [];
        }
        groupedLinks[targetID].push(link);
      } else {
        if (!groupedLinks[link.target]) {
          groupedLinks[link.target] = [];
        }
        groupedLinks[link.target].push(link);
      }
    });
    Object.keys(groupedLinks).forEach((targetId) => {
      groupedLinks[targetId].forEach((link, index) => {
        link.i = index;
      });
      groupedLinks[targetId].sort((a, b) => (a.index ?? 0) - (b.index ?? 0));
    });
  });
}
async function renderNodes(graph2) {
  await getNodeTemplates.bind(this)(graph2);
  graph2.nodes.forEach((node) => {
    node.forceSimulation = this;
  });
  spawnNodes(graph2.nodes);
  const nodeShapes = this.selectionGroups.nodes.selectAll("[data-object='node']").data(graph2.nodes, (d) => d.id);
  nodeShapes.enter().append(Node.bind(this)).attr("data-object", "node").style("pointer-events", "fill").call(dragNode.bind(this)()).on("click", (e, d) => {
    this.eventStore.emit(Event.NodeClick, e, d);
    e.stopPropagation();
  }).on("dblclick", (e, d) => {
    this.eventStore.emit(Event.NodeDoubleClick, e, d);
    e.stopPropagation();
  }).on("contextmenu", (e, d) => {
    this.eventStore.emit(Event.NodeContextMenu, e, d);
    e.stopPropagation();
  }).attr("opacity", 0).transition().duration(this.animationDuration).attr("opacity", 1);
  nodeShapes.exit().transition().duration(this.animationDuration).attr("opacity", 0).each((d) => {
    this.deregisterOnZoom(d.id);
    this.nodeDataStore.remove(d.id);
  }).remove();
  nodeShapes.each((d) => {
    const node = nodeShapes.filter((n) => n.id === d.id);
    node.select(Node);
  }).attr("opacity", 1);
}
function renderLinks(graph2) {
  const linkShapes = this.selectionGroups.links.selectAll("[data-object='link']").data(graph2.links, (d) => linkID(d));
  const linkShape = linkShapes.enter().append("g").attr("data-object", "link").attr("data-id", (d) => linkID(d)).classed("gly-link", true).on("click", (e, d) => {
    this.eventStore.emit(Event.LinkClick, e, d);
    e.stopPropagation();
  }).on("dblclick", (e, d) => {
    this.eventStore.emit(Event.LinkDoubleClick, e, d);
    e.stopPropagation();
  }).on("contextmenu", (e, d) => {
    this.eventStore.emit(Event.LinkContextMenu, e, d);
    e.stopPropagation();
  });
  linkShape.append("path").attr("data-object", "link-line-full").attr("fill", "none").attr("stroke", "none");
  linkShape.append("path").attr("id", (d) => `link-path-${linkID(d)}`).attr("data-object", "link-line").classed("gly-link-line", true).classed("solid", (d) => !d.type ? true : d.type === LinkType.Solid).classed("dashed", (d) => d.type === LinkType.Dashed).classed("dotted", (d) => d.type === LinkType.Dotted).classed("hidden", (d) => d.type === LinkType.Hidden).style("stroke", (d) => d.color ?? null).style("stroke-width", (d) => d.width ?? null);
  linkShape.append("path").attr("data-object", "link-arrow-head").classed("gly-link-arrow", true).classed("gly-link-arrow-head", true).classed("hidden", (d) => d.type === LinkType.Hidden).style("stroke", (d) => d.color ?? null).style("stroke-width", (d) => d.width ?? null);
  linkShape.append("path").attr("data-object", "link-arrow-tail").classed("gly-link-arrow", true).classed("gly-link-arrow-tail", true).classed("hidden", (d) => d.type === LinkType.Hidden).style("stroke", (d) => d.color ?? null).style("stroke-width", (d) => d.width ?? null);
  const linkLabel = linkShape.append("text").attr("data-object", "link-label").classed("gly-link-label", true).attr("text-anchor", "middle").attr("dy", "-0.5em").attr("dominant-baseline", "central").style("fill", (d) => d.color ?? null);
  linkLabel.append("textPath").attr("data-object", "link-label-path").attr("xlink:href", (d) => `#link-path-${linkID(d)}`).attr("startOffset", "50%").text((d) => d.type !== LinkType.Hidden ? d.label ?? "" : "");
  linkShape.attr("opacity", 0).transition().duration(this.animationDuration).attr("opacity", 1);
  linkShapes.exit().transition().duration(this.animationDuration).attr("opacity", 0).remove();
  linkShapes.attr("opacity", 1);
  linkShapes.select("[data-object='link-line']").classed("solid", (d) => !d.type ? true : d.type === LinkType.Solid).classed("dashed", (d) => d.type === LinkType.Dashed).classed("dotted", (d) => d.type === LinkType.Dotted).classed("hidden", (d) => d.type === LinkType.Hidden).style("stroke-width", (d) => d.width ?? null);
  linkShapes.select("[data-object='link-arrow-head']").classed("hidden", (d) => d.type === LinkType.Hidden).style("stroke-width", (d) => d.width ?? null);
  linkShapes.select("[data-object='link-arrow-tail']").classed("hidden", (d) => d.type === LinkType.Hidden).style("stroke-width", (d) => d.width ?? null);
  linkShapes.select("[data-object='link-label-path']").text((d) => d.type !== LinkType.Hidden ? d.label ?? "" : "");
}
async function getNodeTemplates(graph2) {
  for (let i in graph2.nodes) {
    const node = graph2.nodes[i];
    await this.templateStore.get(node).then((template) => {
      node.shape.template = template;
    });
  }
}
function spawnNodes(nodes) {
  var _a, _b, _c, _d, _e, _f;
  for (let node of nodes) {
    if (node.x || node.y)
      continue;
    if (node.fx || node.fy)
      continue;
    if (((_a = node.anchor) == null ? void 0 : _a.x) || ((_b = node.anchor) == null ? void 0 : _b.y))
      continue;
    if (((_c = node.satellite) == null ? void 0 : _c.x) || ((_d = node.satellite) == null ? void 0 : _d.y))
      continue;
    if (node.spawn) {
      const sourceID = typeof node.spawn.source === "string" ? node.spawn.source : node.spawn.source.id;
      const sourceNode = nodes.find((n) => n.id === sourceID);
      const sourcePos = {
        x: (sourceNode == null ? void 0 : sourceNode.x) ?? (sourceNode == null ? void 0 : sourceNode.fx) ?? ((_e = sourceNode == null ? void 0 : sourceNode.anchor) == null ? void 0 : _e.x) ?? 0,
        y: (sourceNode == null ? void 0 : sourceNode.y) ?? (sourceNode == null ? void 0 : sourceNode.fy) ?? ((_f = sourceNode == null ? void 0 : sourceNode.anchor) == null ? void 0 : _f.y) ?? 0
      };
      const distance = node.spawn.distance;
      const angle = node.spawn.angle;
      const pos = {
        x: sourcePos.x + distance * Math.cos(angle * Math.PI / 180 - Math.PI / 2),
        y: sourcePos.y + distance * Math.sin(angle * Math.PI / 180 - Math.PI / 2)
      };
      node.x = pos.x;
      node.y = pos.y;
      continue;
    }
    const { x, y } = defaultPlacement(nodes);
    node.x = x;
    node.y = y;
  }
}
function defaultPlacement(nodes, pos = { x: 0, y: 0 }) {
  if (!nodes.find((n) => n.x === pos.x && n.y === pos.y)) {
    return pos;
  }
  return defaultPlacement(nodes, { x: pos.x + 1, y: pos.y });
}
function linkID(link) {
  if (!link.id)
    link.id = Math.random().toString(36).substring(2, 34) + Math.random().toString(36).substring(2, 34);
  if (link.id)
    return link.id;
  return (typeof link.source === "string" ? link.source : link.source.id) + (typeof link.target === "string" ? link.target : link.target.id) + link.type + link.directed + link.label + link.strength;
}
function lineFull(link) {
  const start = lineStart(link);
  const end = lineEnd(link);
  const center = lineCenterWithOffset(start, end, offset(link, start, end, 0.1));
  const points = {
    start,
    center,
    end
  };
  if (!points)
    return;
  return `M ${points.start.x} ${points.start.y}Q ${points.center.x}, ${points.center.y} ${points.end.x} ${points.end.y}`;
}
function line(link) {
  const points = getSurfacePoints(link, link.padding ?? 10);
  if (!points)
    return;
  const left = points.start.x > points.end.x;
  const start = {
    x: left ? points.end.x : points.start.x,
    y: left ? points.end.y : points.start.y
  };
  const end = {
    x: left ? points.start.x : points.end.x,
    y: left ? points.start.y : points.end.y
  };
  return `M ${start.x} ${start.y}Q ${points.center.x}, ${points.center.y} ${end.x} ${end.y}`;
}
function arrow(link, arrowPos = ArrowDirection.Head) {
  if (!link.directed)
    return "";
  if (arrowPos == ArrowDirection.Head && link.directed !== true && arrowPos == ArrowDirection.Head && link.directed != ArrowDirection.Head && arrowPos == ArrowDirection.Head && link.directed != ArrowDirection.Both)
    return "";
  if (arrowPos == ArrowDirection.Tail && link.directed != ArrowDirection.Tail && arrowPos == ArrowDirection.Tail && link.directed != ArrowDirection.Both)
    return "";
  const padding = link.padding ?? 10;
  const points = getSurfacePoints(link, padding);
  if (!points)
    return;
  const arrowAngle = arrowPos == ArrowDirection.Head ? Math.atan2(points.end.y - points.center.y, points.end.x - points.center.x) : Math.atan2(points.start.y - points.center.y, points.start.x - points.center.x);
  const arrowRadius = 10;
  const arrowStart = arrowPos == ArrowDirection.Head ? {
    x: points.end.x + arrowRadius * Math.cos(arrowAngle + Math.PI / 2),
    y: points.end.y + arrowRadius * Math.sin(arrowAngle + Math.PI / 2)
  } : {
    x: points.start.x + arrowRadius * Math.cos(arrowAngle + Math.PI / 2),
    y: points.start.y + arrowRadius * Math.sin(arrowAngle + Math.PI / 2)
  };
  const arrowTip = arrowPos == ArrowDirection.Head ? {
    x: points.end.x + arrowRadius * Math.cos(arrowAngle),
    y: points.end.y + arrowRadius * Math.sin(arrowAngle)
  } : {
    x: points.start.x + arrowRadius * Math.cos(arrowAngle),
    y: points.start.y + arrowRadius * Math.sin(arrowAngle)
  };
  const arrowEnd = arrowPos == ArrowDirection.Head ? {
    x: points.end.x + arrowRadius * Math.cos(arrowAngle - Math.PI / 2),
    y: points.end.y + arrowRadius * Math.sin(arrowAngle - Math.PI / 2)
  } : {
    x: points.start.x + arrowRadius * Math.cos(arrowAngle - Math.PI / 2),
    y: points.start.y + arrowRadius * Math.sin(arrowAngle - Math.PI / 2)
  };
  return `M ${arrowStart.x} ${arrowStart.y}L ${arrowTip.x} ${arrowTip.y}L ${arrowEnd.x} ${arrowEnd.y}`;
}
function labelDy(link) {
  const points = getSurfacePoints(link, link.padding ?? 10);
  if (!points)
    return;
  return points.start.x > points.end.x ? "0.5em" : "-0.5em";
}
function lineStart(link) {
  if (typeof link.source === "string" || typeof link.target === "string")
    return { x: 0, y: 0 };
  return calculateStartpoint(link.target, link.source);
}
function lineEnd(link) {
  if (typeof link.source === "string" || typeof link.target === "string")
    return { x: 0, y: 0 };
  return calculateStartpoint(link.source, link.target);
}
function lineCenter(start, end) {
  return { x: (start.x + end.x) / 2, y: (start.y + end.y) / 2 };
}
function lineCenterWithOffset(start, end, offset2) {
  const lc = lineCenter(start, end);
  return { x: lc.x + ((offset2 == null ? void 0 : offset2.x) ?? 0), y: lc.y - ((offset2 == null ? void 0 : offset2.y) ?? 0) };
}
function offset(link, start, end, bezierCurveFactor) {
  const dX = dx(start, end);
  const dY = dy(start, end);
  const normal = normalize(dX, dY);
  const curvature = link.curvature !== void 0 ? link.curvature : bezierCurveFactor;
  const indexFactor = link.curvature !== void 0 ? 1 : (link.i ?? 0) + 1;
  const x = curvature * (dY / normal) * normal * indexFactor;
  const y = curvature * (dX / normal) * normal * indexFactor;
  return { x, y };
}
function dx(start, end) {
  return end.x - start.x;
}
function dy(start, end) {
  return end.y - start.y;
}
function normalize(dx2, dy2) {
  return Math.sqrt(dx2 * dx2 + dy2 * dy2);
}
function calculateStartpoint(source, target) {
  const dx2 = (target.x ?? 0) - (source.x ?? 0);
  const dy2 = (target.y ?? 0) - (source.y ?? 0);
  const length = Math.sqrt(dx2 * dx2 + dy2 * dy2);
  if (length === 0)
    return { x: source.x ?? 0, y: source.y ?? 0 };
  return { x: dx2 + (source.x ?? 0), y: dy2 + (source.y ?? 0) };
}
function getSurfacePoints(link, distance = 0) {
  var _a, _b;
  const start = lineStart(link);
  const end = lineEnd(link);
  const off = offset(link, start, end, 0.1);
  if (typeof link.source === "string" || typeof link.target === "string")
    return { start, end, center: off };
  const center = lineCenterWithOffset(
    { x: link.source.x ?? 0, y: link.source.y ?? 0 },
    { x: link.target.x ?? 0, y: link.target.y ?? 0 },
    off
  );
  const arrowHeadDistance = link.directed === true || link.directed == ArrowDirection.Head || link.directed == ArrowDirection.Both ? 20 : 0;
  const arrowTailDistance = link.directed == ArrowDirection.Tail || link.directed == ArrowDirection.Both ? 20 : 0;
  const path = create("g").append("path").attr("d", `M ${start.x} ${start.y}Q ${center.x}, ${center.y} ${end.x} ${end.y}`).node();
  if (!path)
    return { start, end, center: off };
  const sourceSize = link.source.shape.failed ? 200 : ((_a = link.source.shape.template) == null ? void 0 : _a.shapeSize) ?? 300;
  const targetSize = link.target.shape.failed ? 200 : ((_b = link.target.shape.template) == null ? void 0 : _b.shapeSize) ?? 300;
  const startIntersection = calculateIntersectionDistance(link.source, link.target, link, false);
  const endIntersection = calculateIntersectionDistance(link.source, link.target, link, true);
  const startDistance = startIntersection || (link.source.shape.scale ?? 1) * (sourceSize / 2);
  const endDistance = endIntersection || (link.target.shape.scale ?? 1) * (targetSize / 2);
  const surfaceStart = path.getAttribute("d").includes("NaN") ? 0 : path.getPointAtLength(startDistance + distance + arrowTailDistance);
  const surfaceEnd = path.getAttribute("d").includes("NaN") ? 0 : path.getPointAtLength(path.getTotalLength() - endDistance - distance - arrowHeadDistance);
  const surfaceOffset = offset(link, surfaceStart, surfaceEnd, 0.1);
  const surfaceCenter = lineCenterWithOffset(surfaceStart, surfaceEnd, surfaceOffset);
  return {
    start: { x: surfaceStart.x, y: surfaceStart.y },
    center: { x: surfaceCenter.x, y: surfaceCenter.y },
    end: { x: surfaceEnd.x, y: surfaceEnd.y }
  };
}
function calculateIntersectionDistance(sourceNode, targetNode, link, reversed = false) {
  var _a, _b;
  const linePath = d3.select("[data-id='" + linkID(link) + "']").select("[data-object='link-line-full']").node();
  if (!linePath || !linePath.getPointAtLength || !linePath.getAttribute("d") || linePath.getAttribute("d").includes("NaN"))
    return 0;
  const bodyPoints = reversed ? targetNode.shape.bodyPoints ?? [] : sourceNode.shape.bodyPoints ?? [];
  if (bodyPoints.length === 0)
    return 0;
  const lineLength = linePath.getTotalLength();
  const stepSize = reversed ? -((((_a = targetNode.shape.template) == null ? void 0 : _a.shapeSize) ?? 300) * (targetNode.shape.scale ?? 1)) / 20 : (((_b = sourceNode.shape.template) == null ? void 0 : _b.shapeSize) ?? 300) * (sourceNode.shape.scale ?? 1) / 20;
  let length = reversed ? lineLength : 0;
  let globalPoint = linePath.getPointAtLength(length);
  let localPoint = { x: 0, y: 0 };
  if (!reversed) {
    localPoint = {
      x: globalPoint.x - (sourceNode.x ?? 0),
      y: globalPoint.y - (sourceNode.y ?? 0)
    };
  } else {
    localPoint = {
      x: globalPoint.x - (targetNode.x ?? 0),
      y: globalPoint.y - (targetNode.y ?? 0)
    };
  }
  let iterations = 0;
  while (pointInPolygon(localPoint, bodyPoints) && length <= lineLength && iterations < 30) {
    iterations++;
    length += stepSize;
    globalPoint = linePath.getPointAtLength(length);
    if (!reversed) {
      localPoint = {
        x: globalPoint.x - (sourceNode.x ?? 0),
        y: globalPoint.y - (sourceNode.y ?? 0)
      };
    } else {
      localPoint = {
        x: globalPoint.x - (targetNode.x ?? 0),
        y: globalPoint.y - (targetNode.y ?? 0)
      };
    }
  }
  iterations = 0;
  while (!pointInPolygon(localPoint, bodyPoints) && length >= 0 && iterations < 30) {
    iterations++;
    length = reversed ? length + 1 : length - 1;
    globalPoint = linePath.getPointAtLength(length);
    if (!reversed) {
      localPoint = {
        x: globalPoint.x - (sourceNode.x ?? 0),
        y: globalPoint.y - (sourceNode.y ?? 0)
      };
    } else {
      localPoint = {
        x: globalPoint.x - (targetNode.x ?? 0),
        y: globalPoint.y - (targetNode.y ?? 0)
      };
    }
  }
  const ditanceFactor = reversed ? (targetNode.shape.scale ?? 1) / (sourceNode.shape.scale ?? 1) : 1;
  const distance = (reversed ? lineLength - length : length) * ditanceFactor;
  return distance;
}
function pointInPolygon(point, polygon) {
  var inside = false;
  for (var i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
    var xi = polygon[i].x, yi = polygon[i].y;
    var xj = polygon[j].x, yj = polygon[j].y;
    var intersect = yi > point.y != yj > point.y && point.x < (xj - xi) * (point.y - yi) / (yj - yi) + xi;
    if (intersect)
      inside = !inside;
  }
  return inside;
}
function linkForce(distance) {
  const force = d3.forceLink().id((d) => d.id).strength((d) => {
    if (d.strength === void 0)
      return 0.3;
    if (typeof d.strength === "number")
      return d.strength;
    switch (d.strength) {
      case LinkStrength.Strong:
        return 0.5;
      case LinkStrength.Weak:
        return 0.3;
      case LinkStrength.Loose:
        return 0;
      default:
        return 0.3;
    }
  }).distance(distance);
  return force;
}
function xForce() {
  const force = d3.forceX().x((d) => position(d).x).strength((d) => strength(d));
  return force;
}
function yForce() {
  const force = d3.forceY().y((d) => position(d).y).strength((d) => strength(d));
  return force;
}
function gravity(envGravity) {
  const force = d3.forceManyBody().strength((d) => {
    if (d.gravity)
      return d.gravity;
    return envGravity;
  });
  return force;
}
function position(d) {
  if (d.satellite)
    return { x: d.satellite.x ?? 0, y: d.satellite.y ?? 0 };
  if (d.anchor)
    return { x: d.anchor.x ?? 0, y: d.anchor.y ?? 0 };
  return { x: 0, y: 0 };
}
function strength(d) {
  if (d.satellite)
    return 6;
  if (d.anchor) {
    switch (d.anchor.type) {
      case AnchorType.Hard:
      case AnchorType.Soft:
        return 2;
      default:
        return 0;
    }
  }
  return 0;
}
function shapeCollide(alpha) {
  const nodes = this.graph.nodes;
  var quadtree = d3.quadtree().x((d) => d.x).y((d) => d.y).addAll(nodes);
  nodes.forEach((d) => {
    var _a;
    d.x = d.x || 0;
    d.y = d.y || 0;
    var r = (((_a = d.shape.template) == null ? void 0 : _a.shapeSize) ?? 300) * d.shape.scale;
    var nx1 = d.x - r;
    var nx2 = d.x + r;
    var ny1 = d.y - r;
    var ny2 = d.y + r;
    quadtree.visit((quad, x1, y1, x2, y2) => {
      var _a2, _b, _c;
      if (quad.data && quad.data !== d) {
        var x = (d.x ?? 0) - quad.data.x;
        var y = (d.y ?? 0) - quad.data.y;
        var l = Math.sqrt(x * x + y * y);
        const r2 = (((_a2 = d.shape.template) == null ? void 0 : _a2.shapeSize) ?? 300) * d.shape.scale;
        if (nearBy(d, quad.data)) {
          if (((_b = d.shape.bodyPoints) == null ? void 0 : _b.length) == 0 || ((_c = quad.data.shape.bodyPoints) == null ? void 0 : _c.length) == 0) {
            if (l < r2) {
              l = (l - r2) / l * alpha;
              d.x = d.x || 0;
              d.y = d.y || 0;
              d.x -= x *= l;
              d.y -= y *= l;
              quad.data.x += x;
              quad.data.y += y;
            }
          } else {
            if (polygonsIntersect(d, quad.data)) {
              l = (l - r2) / l * alpha;
              d.x = d.x || 0;
              d.y = d.y || 0;
              d.x -= x *= l;
              d.y -= y *= l;
              quad.data.x += x;
              quad.data.y += y;
            }
          }
        }
      }
      return x1 > nx2 || x2 < nx1 || y1 > ny2 || y2 < ny1;
    });
  });
}
function nearBy(n1, n2) {
  var _a, _b, _c, _d;
  const n1Pos = { x: n1.x ?? 0, y: n1.y ?? 0 };
  const n1Radius = (((_b = (_a = n1.shape) == null ? void 0 : _a.template) == null ? void 0 : _b.shapeSize) ?? 300) / 2 * (n1.shape.scale * 1.5);
  const n2Pos = { x: n2.x ?? 0, y: n2.y ?? 0 };
  const n2Radius = (((_d = (_c = n2.shape) == null ? void 0 : _c.template) == null ? void 0 : _d.shapeSize) ?? 300) / 2 * (n2.shape.scale * 1.5);
  const distance = Math.sqrt(Math.pow(n1Pos.x - n2Pos.x, 2) + Math.pow(n1Pos.y - n2Pos.y, 2));
  return distance < n1Radius + n2Radius;
}
function polygonsIntersect(n1, n2) {
  const n1p = (n1.shape.bodyPoints ?? []).map((p) => ({ x: p.x - (n1.x ?? 0), y: p.y - (n1.y ?? 0) }));
  const n2p = (n2.shape.bodyPoints ?? []).map((p) => ({ x: p.x - (n2.x ?? 0), y: p.y - (n2.y ?? 0) }));
  for (let i = 0; i < n1p.length; i++) {
    const point = {
      x: n1p[i].x,
      y: n1p[i].y
    };
    if (pointInPolygon(point, n2p))
      return true;
  }
  return false;
}
function ticked() {
  for (let i in this.graph.nodes) {
    if (this.graph.nodes[i].isDraged)
      continue;
    processSatellite(this.graph, this.graph.nodes[i]);
    processAnchor(this.graph.nodes[i]);
  }
  this.selectionGroups.nodes.selectAll("[data-object='node']").attr("transform", (d) => `translate(${d.x ?? 0},${d.y ?? 0})`);
  this.selectionGroups.links.selectAll("[data-object='link']").call((d) => {
    const lf = d.select("[data-object='link-line-full']");
    lf.attr("d", lineFull);
    const l = d.select("[data-object='link-line']");
    l.attr("d", line);
    const headArrow = d.select("[data-object='link-arrow-head']");
    headArrow.attr("d", (d2) => arrow(d2, ArrowDirection.Head));
    const tailArrow = d.select("[data-object='link-arrow-tail']");
    tailArrow.attr("d", (d2) => arrow(d2, ArrowDirection.Tail));
    const label = d.select("[data-object='link-label']");
    label.attr("dy", labelDy);
  });
  this.simulation.force("forceX").x((d) => position(d).x).strength((d) => strength(d));
  this.simulation.force("forceY").y((d) => position(d).y).strength((d) => strength(d));
  this.eventStore.emit(Event.SimulationTick);
}
function processSatellite(graph2, d) {
  var _a, _b, _c, _d;
  if (!d.satellite)
    return;
  if (typeof d.satellite.source === "string") {
    const source = graph2.nodes.find((n) => n.id === d.satellite.source);
    if (!source)
      return;
    d.satellite.source = source;
  }
  const distance = d.satellite.distance ?? 400;
  const angle = d.satellite.angle ?? 0;
  const pos = {
    x: (((_b = (_a = d.satellite) == null ? void 0 : _a.source) == null ? void 0 : _b.x) ?? 0) + distance * Math.cos(angle * Math.PI / 180 - Math.PI / 2),
    y: (((_d = (_c = d.satellite) == null ? void 0 : _c.source) == null ? void 0 : _d.y) ?? 0) + distance * Math.sin(angle * Math.PI / 180 - Math.PI / 2)
  };
  d.satellite.x = pos.x;
  d.satellite.y = pos.y;
  if (d.satellite.type === SatelliteType.Hard) {
    d.fx = pos.x;
    d.fy = pos.y;
  }
}
function processAnchor(d) {
  if (d.satellite)
    return;
  if (!d.anchor)
    return;
  d.fx = null;
  d.fy = null;
  if (d.anchor.type === AnchorType.Hard) {
    d.fx = d.anchor.x;
    d.fy = d.anchor.y;
  }
}
function createZoom() {
  const zoom = d3.zoom().extent([
    [0, 0],
    [this.svgElement.clientWidth, this.svgElement.clientHeight]
  ]).scaleExtent([0.1, 3]).on("zoom", ({ transform: transform2 }) => onZoom.bind(this)(transform2));
  this.svgSelection.call(zoom).call(
    zoom.transform,
    d3.zoomIdentity.translate(this.worldTransform.x, this.worldTransform.y).scale(this.worldTransform.k)
  );
  this.svgSelection.on("dblclick.zoom", null);
  return zoom;
}
function onZoom(transform2) {
  this.selectionGroups.world.attr("transform", `translate(${transform2.x}, ${transform2.y}) scale(${transform2.k})`);
  if (this.worldTransform.k != transform2.k) {
    const movedRange = [this.worldTransform.k, transform2.k].sort();
    Object.keys(this.onZoomRoutines).forEach((t) => {
      const threshold = parseFloat(t);
      if (threshold > movedRange[0] && threshold < movedRange[1]) {
        this.onZoomRoutines[threshold].forEach((routine) => routine(transform2.k));
      }
    });
  }
  this.worldTransform = transform2;
  this.eventStore.emit(Event.EnvironmentMove, transform2);
}
function moveTo(options, onZoom2) {
  if (options.transform) {
    return moveToTransform.bind(this)(options.transform, onZoom2, options.duration);
  }
  const boundaries = [];
  if (options.boundaries) {
    boundaries.push(cumulatedBoundary(options.boundaries));
  }
  if (options.nodes) {
    boundaries.push(nodesBoundary(options.nodes));
  }
  moveToBoundary.bind(this)(cumulatedBoundary(boundaries), onZoom2, options.duration, options.padding);
}
function cumulatedBoundary(boundaries) {
  let minX = boundaries.reduce((acc, b) => Math.min(acc, b.x), Infinity);
  let minY = boundaries.reduce((acc, b) => Math.min(acc, b.y), Infinity);
  let maxX = boundaries.reduce((acc, b) => Math.max(acc, b.x + b.width), -Infinity);
  let maxY = boundaries.reduce((acc, b) => Math.max(acc, b.y + b.height), -Infinity);
  return {
    x: minX,
    y: minY,
    width: maxX - minX,
    height: maxY - minY
  };
}
function nodesBoundary(nodes) {
  const bounds = d3.extent(nodes, (n) => n.x);
  const x = d3.extent(nodes, (n) => n.y);
  const width = (bounds[1] ?? 0) - (bounds[0] ?? 0);
  const height = (x[1] ?? 0) - (x[0] ?? 0);
  const largestNodeSize = d3.max(nodes.map((n) => {
    var _a;
    return n.shape.scale * (((_a = n.shape.template) == null ? void 0 : _a.shapeSize) ?? 300);
  })) ?? 0;
  return {
    x: (bounds[0] ?? 0) - largestNodeSize / 2,
    y: (x[0] ?? 0) - largestNodeSize / 2,
    width: width + largestNodeSize,
    height: height + largestNodeSize
  };
}
function moveToTransform(t, onZoom2, duration) {
  const svgWidth = this.svgElement.clientWidth;
  const svgHeight = this.svgElement.clientHeight;
  const centerOffset = { x: svgWidth / 2, y: svgHeight / 2 };
  const targetTransform = {
    x: -t.x + svgWidth / 2 * (1 - t.k) * (t.x / (svgWidth / 2)) + centerOffset.x,
    y: -t.y + svgHeight / 2 * (1 - t.k) * (t.y / (svgHeight / 2)) + centerOffset.y,
    k: t.k
  };
  transform.bind(this)(targetTransform, onZoom2, duration);
}
function moveToBoundary(boundary, onZoom2, duration, padding) {
  const svgWidth = this.svgElement.clientWidth;
  const svgHeight = this.svgElement.clientHeight;
  const svgAspectRatio = svgWidth / svgHeight;
  const boundaryAspectRatio = (boundary.width + (padding ?? 0) * 2) / (boundary.height + (padding ?? 0) * 2);
  const scale = svgAspectRatio < boundaryAspectRatio ? svgWidth / (boundary.width + (padding ?? 0) * 2) : svgHeight / (boundary.height + (padding ?? 0) * 2);
  const targetTransform = {
    x: boundary.x + boundary.width / 2,
    y: boundary.y + boundary.height / 2,
    k: scale
  };
  moveToTransform.bind(this)(targetTransform, onZoom2, duration);
}
function transform(t, onZoom2, duration) {
  if (isNaN(t.x) || isNaN(t.y) || isNaN(t.k))
    return;
  this.selectionGroups.world.transition().duration(duration ?? 1e3).ease(d3.easePolyInOut).attr("transform", `translate(${t.x},${t.y}) scale(${t.k})`).on("end", () => {
    onZoom2(t);
  });
}
function exportGraph() {
  const nodes = [];
  const links = [];
  this.graph.nodes.forEach((node) => {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    const exportNode = {
      id: node.id,
      x: node.x,
      y: node.y,
      shape: {
        type: node.shape.type,
        scale: node.shape.scale,
        url: node.shape.url
      },
      gravity: node.gravity,
      anchor: {
        type: ((_a = node.anchor) == null ? void 0 : _a.type) || "",
        x: ((_b = node.anchor) == null ? void 0 : _b.x) || 0,
        y: ((_c = node.anchor) == null ? void 0 : _c.y) || 0
      },
      satellite: {
        source: typeof ((_d = node.satellite) == null ? void 0 : _d.source) === "string" ? node.satellite.source : ((_f = (_e = node.satellite) == null ? void 0 : _e.source) == null ? void 0 : _f.id) || "",
        angle: ((_g = node.satellite) == null ? void 0 : _g.angle) || 0,
        distance: ((_h = node.satellite) == null ? void 0 : _h.distance) || 0
      },
      payload: node.payload
    };
    nodes.push(exportNode);
  });
  this.graph.links.forEach((link) => {
    const exportLink = {
      source: typeof link.source === "string" ? link.source : link.source.id,
      target: typeof link.target === "string" ? link.target : link.target.id,
      id: link.id,
      type: link.type,
      directed: link.directed,
      label: link.label,
      strength: link.strength,
      padding: link.padding,
      width: link.width,
      curvature: link.curvature,
      payload: link.payload
    };
    links.push(exportLink);
  });
  return {
    nodes,
    links
  };
}
const graph = "";
class ForceSimulation {
  constructor(svgEl) {
    __publicField(this, "debug", {
      enabled: false,
      bodyPoints: {
        enabled: true,
        color: "#00ffff"
      }
    });
    __publicField(this, "_svgElement");
    __publicField(this, "_svgSelection");
    __publicField(this, "_simulation");
    __publicField(this, "_selectedNodes", []);
    __publicField(this, "_zoom");
    __publicField(this, "worldTransform", { x: 0, y: 0, k: 1 });
    __publicField(this, "_onZoomRegister", []);
    __publicField(this, "_onZoomRoutines", {});
    __publicField(this, "animationDuration", 300);
    __publicField(this, "draggableNodes", true);
    __publicField(this, "selectionGroups");
    __publicField(this, "graph", { nodes: [], links: [] });
    __publicField(this, "templateStore", new TemplateStore());
    __publicField(this, "nodeDataStore", new NodeDataStore());
    __publicField(this, "eventStore", new EventStore());
    __publicField(this, "theme", "light");
    __publicField(this, "themeChangeObserver", new MutationObserver((mutations) => {
      mutations.forEach((mutation) => {
        if (mutation.attributeName === "class") {
          const element = mutation.target;
          const theme = element.classList.contains("dark") ? "dark" : "light";
          this.eventStore.emit(Event.ThemeChange, theme);
        }
      });
    }));
    if (svgEl instanceof SVGElement) {
      this._svgElement = svgEl;
      this._svgSelection = d3.select(svgEl);
    } else {
      this._svgSelection = svgEl;
      this._svgElement = svgEl.node();
    }
    this.worldTransform = { x: this.svgElement.clientWidth / 2, y: this.svgElement.clientHeight / 2, k: 1 };
    this._simulation = this.createSimulation();
    this.selectionGroups = this.createWorld();
    this._zoom = createZoom.bind(this)();
    this.setEvents();
  }
  get svgElement() {
    return this._svgElement;
  }
  set svgElement(svgElement) {
    this._svgElement = svgElement;
    this._svgSelection = d3.select(svgElement);
    this.selectionGroups = this.createWorld();
    this._zoom = createZoom.bind(this)();
    this.themeChangeObserver.disconnect();
    this.setEvents();
    this.render(this.graph);
  }
  get svgSelection() {
    return this._svgSelection;
  }
  get simulation() {
    return this._simulation;
  }
  get selectedNodes() {
    return this._selectedNodes;
  }
  set selectedNodes(ids) {
    this._selectedNodes = ids;
    this.selectNodes();
  }
  get worldBounds() {
    const { x, y, k } = this.worldTransform;
    const bounds = {
      x: -(x / k),
      y: -(y / k),
      width: this.svgElement.clientWidth / k,
      height: this.svgElement.clientHeight / k
    };
    return bounds;
  }
  set zoomScaleExtent(extent) {
    this._zoom.scaleExtent(extent);
  }
  set zoomEnabled(enabled) {
    this._zoom.on("zoom", null);
    if (enabled)
      this._zoom.on("zoom", ({ transform: transform2 }) => onZoom.bind(this)(transform2));
  }
  get onZoomRegister() {
    return this._onZoomRegister;
  }
  get onZoomRoutines() {
    return this._onZoomRoutines;
  }
  set envGravity(value) {
    this.simulation.force("gravity", gravity(value));
  }
  set linkDistance(value) {
    this.simulation.force("link", linkForce(value));
  }
  createSimulation() {
    const simulation = d3.forceSimulation().force("link", linkForce(400)).force("forceX", xForce()).force("forceY", yForce()).force("gravity", gravity(-1e4)).force("shapeCollide", shapeCollide.bind(this)).on("tick", ticked.bind(this)).on("end", () => {
      this.eventStore.emit(Event.SimulationTickEnd);
    });
    return simulation;
  }
  createWorld() {
    const world = this.svgSelection.append("g").attr("data-object", "world");
    const links = world.append("g").attr("data-object", "links");
    const nodes = world.append("g").attr("data-object", "nodes");
    return { world, nodes, links };
  }
  setEvents() {
    function pos(e) {
      return {
        x: this.worldBounds.x + e.offsetX / this.worldTransform.k,
        y: this.worldBounds.y + e.offsetY / this.worldTransform.k
      };
    }
    this.svgSelection.on("click", (e) => this.eventStore.emit(Event.EnvironmentClick, e, pos.bind(this)(e)));
    this.svgSelection.on(
      "dblclick",
      (e) => this.eventStore.emit(Event.EnvironmentDoubleClick, e, pos.bind(this)(e))
    );
    this.svgSelection.on(
      "contextmenu",
      (e) => this.eventStore.emit(Event.EnvironmentContextMenu, e, pos.bind(this)(e))
    );
    this.themeChangeObserver.observe(this.svgElement, { attributes: true });
  }
  registerOnZoom(id, threshold, callback) {
    this.deregisterOnZoom(id);
    this._onZoomRegister.push({ id, threshold, callback });
    this._onZoomRoutines = {};
    this._onZoomRegister.forEach((registration) => {
      if (!this._onZoomRoutines[registration.threshold])
        this._onZoomRoutines[registration.threshold] = [];
      this._onZoomRoutines[registration.threshold].push(registration.callback);
    });
  }
  deregisterOnZoom(id) {
    this._onZoomRegister = this._onZoomRegister.filter(({ id: i }) => i !== id);
  }
  selectNodes() {
    this.selectionGroups.nodes.selectAll(".gly-selectable").classed("gly-selected", false);
    this.selectionGroups.nodes.selectAll("[data-object='node']").filter((d) => this.selectedNodes.includes(d.id)).selectAll(".gly-selectable").classed("gly-selected", true);
  }
  async render(graph2, alpha = 0.05, forced = false) {
    this.theme = this.svgElement.classList.contains("dark") ? "dark" : "light";
    if (forced) {
      this.nodeDataStore.clear();
      this.selectionGroups.nodes.selectAll("*").remove();
      this.selectionGroups.links.selectAll("*").remove();
    }
    this.graph = graph2;
    await renderNodes.bind(this)(this.graph).then(() => {
      indexLinks(graph2);
      renderLinks.bind(this)(this.graph);
      this.simulation.nodes(this.graph.nodes);
      this.simulation.force("link").links(graph2.links);
      this.simulation.alphaTarget(alpha).restart();
      setTimeout(() => {
        this.simulation.alphaTarget(0);
      }, 100);
      this.selectNodes();
    });
  }
  snapshot(ticks = 0) {
    const simulation = this.simulation;
    simulation.tick(ticks);
    const clone = this.svgElement.cloneNode(true);
    return clone;
  }
  exportGraph() {
    return exportGraph.bind(this)();
  }
  moveTo(options) {
    moveTo.bind(this)(options, (t) => {
      this.svgSelection.call(this._zoom.transform, d3.zoomIdentity.translate(t.x, t.y).scale(t.k));
    });
  }
  on(event, callback) {
    this.eventStore.on(event, callback);
  }
}
export {
  AnchorType,
  ArrowDirection,
  Event,
  ForceSimulation,
  LinkStrength,
  LinkType,
  SatelliteType,
  TemplateAPI,
  renderTemplate
};
