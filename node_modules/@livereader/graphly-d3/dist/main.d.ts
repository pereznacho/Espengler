import * as d3_2 from 'd3';

declare enum Alignment {
    Left = "left",
    Center = "center",
    Right = "right"
}

export declare type Anchor = {
    type: AnchorType | "soft" | "hard";
    x: number;
    y: number;
};

export declare enum AnchorType {
    Soft = "soft",
    Hard = "hard"
}

declare function applyLODStyles(k: number, styles: LODStyle[]): void;

declare function applyStyles(shape: d3_2.Selection<any, any, any, any>, styles: ShapeStyle[]): void;

export declare enum ArrowDirection {
    Head = "head",
    Tail = "tail",
    Both = "both"
}

declare interface Boundary {
    x: number;
    y: number;
    width: number;
    height: number;
}

declare function BreakLine(): BreakLine;

declare type BreakLine = "break-line";

declare function brightness(color: string): number;

declare function Circle(radius: number): d3_2.Selection<SVGElement, any, any, any>;

declare function CollectionStyle(height: number, width: number, x: number, y: number, dx: number, dy: number, rowCount: number, align?: Alignment, rowMargins?: number[]): CollectionStyle;

declare interface CollectionStyle {
    height: number;
    width: number;
    x: number;
    y: number;
    dx: number;
    dy: number;
    rowCount: number;
    align: Alignment;
    rowMargins: number[];
}

declare function create(type: string): d3_2.Selection<SVGElement, any, any, any>;

export declare interface D3Link {
    source: string | Node_2;
    target: string | Node_2;
    index?: number;
    i?: number;
}

export declare type D3Node = {
    id: string;
    x?: number;
    y?: number;
    vx?: number;
    vy?: number;
    fx?: number | null;
    fy?: number | null;
};

declare function EmitEvent(identifier: string, data: Node_2, event: any, ...args: any[]): void;

declare enum Event_2 {
    NodeClick = "node:click",
    NodeDoubleClick = "node:doubleclick",
    NodeContextMenu = "node:contextmenu",
    NodeDragStart = "node:dragstart",
    NodeDragMove = "node:dragmove",
    NodeDragEnd = "node:dragend",
    LinkClick = "link:click",
    LinkDoubleClick = "link:doubleclick",
    LinkContextMenu = "link:contextmenu",
    LinkDragStart = "link:dragstart",
    LinkDragMove = "link:dragmove",
    LinkDragEnd = "link:dragend",
    EnvironmentClick = "environment:click",
    EnvironmentDoubleClick = "environment:doubleclick",
    EnvironmentContextMenu = "environment:contextmenu",
    EnvironmentMove = "environment:move",
    ThemeChange = "theme:change",
    SimulationTick = "simulation:tick",
    SimulationTickEnd = "simulation:tickend"
}
export { Event_2 as Event }

declare class EventStore {
    static readonly events: {
        [key: string]: {
            [key: string]: (...args: any[]) => void;
        };
    };
    private register;
    on(event: string, callback: (...args: any[]) => void): void;
    off(event: string, callback: (...args: any[]) => void): void;
    emit(event: string, ...args: any[]): any;
}

declare interface ExportGraph {
    nodes: ExportNode[];
    links: ExportLink[];
}

declare interface ExportLink {
    source: string;
    target: string;
    id?: string;
    type?: string;
    directed?: boolean | string;
    label?: string;
    strength?: number | string;
    padding?: number;
    width?: number;
    curvature?: number;
    payload?: any;
}

declare interface ExportNode {
    id: string;
    x?: number;
    y?: number;
    shape: {
        type: string;
        scale: number;
        url?: string;
    };
    gravity?: number;
    anchor?: {
        type: string;
        x: number;
        y: number;
    };
    satellite?: {
        source: string;
        angle: number;
        distance: number;
    };
    payload?: any;
}

export declare class ForceSimulation {
    debug: {
        enabled: boolean;
        bodyPoints: {
            enabled: boolean;
            color: string;
        };
    };
    private _svgElement;
    get svgElement(): SVGElement;
    set svgElement(svgElement: SVGElement);
    private _svgSelection;
    get svgSelection(): d3_2.Selection<SVGElement, any, any, any>;
    private _simulation;
    get simulation(): d3_2.Simulation<Node_2, Link>;
    private _selectedNodes;
    get selectedNodes(): string[];
    set selectedNodes(ids: string[]);
    private _zoom;
    worldTransform: {
        x: number;
        y: number;
        k: number;
    };
    get worldBounds(): Boundary;
    set zoomScaleExtent(extent: [number, number]);
    set zoomEnabled(enabled: boolean);
    private _onZoomRegister;
    get onZoomRegister(): {
        id: string;
        threshold: number;
        callback: (k: number) => boolean;
    }[];
    private _onZoomRoutines;
    get onZoomRoutines(): {
        [threshold: number]: ((k: number) => boolean)[];
    };
    set envGravity(value: number);
    set linkDistance(value: number);
    animationDuration: number;
    draggableNodes: boolean;
    selectionGroups: SelectionGroups;
    graph: Graph;
    templateStore: TemplateStore;
    nodeDataStore: NodeDataStore;
    readonly eventStore: EventStore;
    constructor(svgEl: SVGElement | d3_2.Selection<SVGElement, any, any, any>);
    private createSimulation;
    private createWorld;
    private setEvents;
    theme: "light" | "dark";
    private themeChangeObserver;
    registerOnZoom(id: string, threshold: number, callback: (k: number) => boolean): void;
    deregisterOnZoom(id: string): void;
    private selectNodes;
    render(this: ForceSimulation, graph: Graph, alpha?: number, forced?: boolean): Promise<void>;
    snapshot(ticks?: number): SVGElement;
    exportGraph(): ExportGraph;
    moveTo(options: MoveOptions): void;
    on(event: string, callback: (...args: any[]) => void): void;
}

declare function getBBox(shape: d3_2.Selection<SVGElement, any, any, any>): SVGRect;

export declare interface Graph {
    nodes: Node_2[];
    links: Link[];
}

declare function isDark(color: string): boolean;

declare function isLight(color: string): boolean;

export declare interface Link extends D3Link {
    id?: string;
    type?: LinkType | "solid" | "dashed" | "dotted" | "hidden";
    directed?: boolean | ArrowDirection | "head" | "tail" | "both";
    label?: string;
    strength?: number | LinkStrength | "strong" | "weak" | "loose";
    padding?: number;
    width?: number;
    curvature?: number;
    color?: string;
    payload?: any;
}

export declare enum LinkStrength {
    Strong = "strong",
    Weak = "weak",
    Loose = "loose"
}

export declare enum LinkType {
    Solid = "solid",
    Dashed = "dashed",
    Dotted = "dotted",
    Hidden = "hidden"
}

declare function LODStyle(shape: d3_2.Selection<any, any, any, any>, key: string, value: string, condition?: ((k: number) => boolean) | boolean): LODStyle;

declare interface LODStyle {
    shape: d3_2.Selection<any, any, any, any>;
    key: string;
    value: string;
    condition: ((k: number) => boolean) | boolean;
}

declare interface MoveOptions {
    transform?: Transform;
    boundaries?: Boundary[];
    nodes?: Node_2[];
    duration?: number;
    padding?: number;
}

declare type Node_2<T = any> = D3Node & {
    shape: Shape;
    renderConfig?: RenderConfig;
    forceSimulation?: ForceSimulation;
    gravity?: number;
    spawn?: Spawn;
    anchor?: Anchor;
    satellite?: Satellite;
    errorMessage?: string;
    payload?: T;
};
export { Node_2 as Node }

declare class NodeDataStore {
    private nodes;
    clear(): void;
    add(id: string, node: Node_2): void;
    remove(id: string): void;
    hasNode(id: string): boolean;
    hasTemplateChange(id: string, data: Node_2): boolean;
    hasPayloadChanges(id: string, data: Node_2): boolean;
    private storeNode;
    private deepCopy;
}

declare function OnThemeChange(data: Node_2, callback: (theme: "light" | "dark") => void): void;

declare function OnZoom(data: Node_2, threshold: number | number[], styles?: LODStyle[]): void;

declare function PathShape(path: string): d3.Selection<SVGElement, any, any, any>;

declare function Polygon(n: number, radius: number, curveRadius?: number): d3_2.Selection<SVGElement, any, any, any>;

declare function prerender(shape: d3_2.Selection<SVGElement, any, any, any>, onElement: (el: SVGGraphicsElement) => void): void;

declare function Rectangle(width: number, height: number, cr?: number): d3_2.Selection<SVGElement, any, any, any>;

export declare type RenderConfig = {
    theme: "light" | "dark";
    scale: number;
};

export declare function renderTemplate(template: Template, data: Node_2, config: RenderConfig): Promise<SVGElement>;

export declare type Satellite = {
    x?: number;
    y?: number;
    type?: SatelliteType | "soft" | "hard";
    source: string | Node_2;
    angle: number;
    distance: number;
};

export declare enum SatelliteType {
    Soft = "soft",
    Hard = "hard"
}

declare interface SelectionGroups {
    world: d3_2.Selection<SVGGElement, any, any, any>;
    nodes: d3_2.Selection<SVGGElement, any, any, any>;
    links: d3_2.Selection<SVGGElement, any, any, any>;
}

export declare type Shape = {
    type: string;
    scale: number;
    url?: string;
    template?: Template;
    bodyPoints?: {
        x: number;
        y: number;
    }[];
    bodyResolution?: number;
    failed?: boolean;
};

declare namespace Shape_2 {
    export {
        prerender,
        getBBox,
        create,
        transform,
        Circle,
        Rectangle,
        Polygon
    }
}

declare function ShapeCollection(shapes: (d3_2.Selection<SVGElement, any, any, any> | BreakLine)[], style: CollectionStyle, ellipsis?: d3_2.Selection<SVGElement, any, any, any> | null): d3_2.Selection<SVGElement, any, any, any>;

declare function ShapeStyle(key: string, value: string | ThemeStyle, condition?: (() => boolean) | boolean): ShapeStyle;

declare interface ShapeStyle {
    key: string;
    value: string | ThemeStyle;
    condition: (() => boolean) | boolean;
}

export declare type Spawn = {
    source: string | Node_2;
    angle: number;
    distance: number;
};

declare function SVGShape(code: string): d3.Selection<SVGElement, any, any, any>;

declare function TagCollection(tags: string[], style: CollectionStyle, tagStyle: TagStyle): d3_2.Selection<SVGElement, any, any, any>;

declare function TagShape(text: string, style: TagStyle): d3_2.Selection<SVGElement, any, any, any>;

declare function TagStyle(padding: number | [number, number] | [number, number, number, number], textStyles?: ShapeStyle[], backgroundStyles?: ShapeStyle[], cornerRadius?: number): TagStyle;

declare interface TagStyle {
    padding: {
        top: number;
        right: number;
        bottom: number;
        left: number;
    };
    textStyles: ShapeStyle[];
    backgroundStyles: ShapeStyle[];
    cornerRadius: number;
}

export declare interface Template<T = any> {
    shapeSize: number;
    shapePayload?: T;
    shapeBuilder: (data: Node_2<T>, TemplateAPI: typeof TemplateAPI) => d3_2.Selection<any, any, any, any>;
}

declare namespace TemplateAPI {
    export {
        Shape_2 as Shape,
        ThemeStyle,
        ShapeStyle,
        LODStyle,
        applyStyles,
        applyLODStyles,
        PathShape,
        SVGShape,
        TagStyle,
        TagShape,
        TextShape,
        BreakLine,
        CollectionStyle,
        ShapeCollection,
        Alignment,
        TextCollection,
        TagCollection,
        OnZoom,
        OnThemeChange,
        brightness,
        isLight,
        isDark,
        EmitEvent
    }
}
export { TemplateAPI }

declare class TemplateStore {
    private _errorTemplate;
    get errorTemplate(): Template;
    private _templates;
    get templates(): {
        [key: string]: Template;
    };
    private failed;
    remoteOrigin: string;
    add(id: string, template: Template): void;
    get(node: Node_2): Promise<Template | undefined>;
    private load;
}

declare function TextCollection(text: string, style: CollectionStyle, textStyles?: ShapeStyle[]): d3_2.Selection<SVGElement, any, any, any>;

/**
 * @param  {String} text
 * @param  {ShapeStyle[]} styles
 * @return {Object} shape
 */
declare function TextShape(text: string, styles?: ShapeStyle[]): d3.Selection<SVGElement, any, any, any>;

declare function ThemeStyle(data: Node_2, lightValue: string, darkValue: string): ThemeStyle;

declare interface ThemeStyle {
    data: Node_2;
    lightValue: string;
    darkValue: string;
}

declare interface Transform {
    x: number;
    y: number;
    k: number;
}

declare function transform(shape: d3_2.Selection<SVGElement, any, any, any>, size: number): {
    scale: number;
    translate: {
        x: number;
        y: number;
    };
};

export { }
