import { AllowedComponentProps } from 'vue';
import { ComponentCustomProps } from 'vue';
import { ComponentOptionsMixin } from 'vue';
import * as d3_2 from 'd3';
import { DefineComponent } from 'vue';
import { ExtractPropTypes } from 'vue';
import { Ref } from 'vue';
import { VNodeProps } from 'vue';

declare enum Alignment {
    Left = "left",
    Center = "center",
    Right = "right"
}

declare type Anchor = {
    type: AnchorType | "soft" | "hard";
    x: number;
    y: number;
};

declare enum AnchorType {
    Soft = "soft",
    Hard = "hard"
}

declare function applyLODStyles(k: number, styles: LODStyle[]): void;

declare function applyStyles(shape: d3_2.Selection<any, any, any, any>, styles: ShapeStyle[]): void;

declare enum ArrowDirection {
    Head = "head",
    Tail = "tail",
    Both = "both"
}

declare interface Boundary {
    x: number;
    y: number;
    width: number;
    height: number;
}

declare function BreakLine(): BreakLine;

declare type BreakLine = "break-line";

declare function brightness(color: string): number;

declare function Circle(radius: number): d3_2.Selection<SVGElement, any, any, any>;

declare function CollectionStyle(height: number, width: number, x: number, y: number, dx: number, dy: number, rowCount: number, align?: Alignment, rowMargins?: number[]): CollectionStyle;

declare interface CollectionStyle {
    height: number;
    width: number;
    x: number;
    y: number;
    dx: number;
    dy: number;
    rowCount: number;
    align: Alignment;
    rowMargins: number[];
}

declare function create(type: string): d3_2.Selection<SVGElement, any, any, any>;

declare interface D3Link {
    source: string | Node_2;
    target: string | Node_2;
    index?: number;
    i?: number;
}

declare type D3Node = {
    id: string;
    x?: number;
    y?: number;
    vx?: number;
    vy?: number;
    fx?: number | null;
    fy?: number | null;
};

declare const _default: DefineComponent<{
    dark: {
        type: BooleanConstructor;
        default: boolean;
    };
    remoteOrigin: {
        type: StringConstructor;
        default: string;
    };
    selectedNodes: {
        type: {
            (arrayLength: number): string[];
            (...items: string[]): string[];
            new (arrayLength: number): string[];
            new (...items: string[]): string[];
            isArray(arg: any): arg is any[];
            readonly prototype: any[];
            from<T>(arrayLike: ArrayLike<T>): T[];
            from<T_1, U>(arrayLike: ArrayLike<T_1>, mapfn: (v: T_1, k: number) => U, thisArg?: any): U[];
            from<T_2>(iterable: Iterable<T_2> | ArrayLike<T_2>): T_2[];
            from<T_3, U_1>(iterable: Iterable<T_3> | ArrayLike<T_3>, mapfn: (v: T_3, k: number) => U_1, thisArg?: any): U_1[];
            of<T_4>(...items: T_4[]): T_4[];
            readonly [Symbol.species]: ArrayConstructor;
        };
        default: () => never[];
    };
    envGravity: {
        type: NumberConstructor;
        default: number;
    };
    linkDistance: {
        type: NumberConstructor;
        default: number;
    };
    animationDuration: {
        type: NumberConstructor;
        default: number;
    };
    draggableNodes: {
        type: BooleanConstructor;
        default: boolean;
    };
    zoomEnabled: {
        type: BooleanConstructor;
        default: boolean;
    };
    zoomScaleExtent: {
        type: {
            (arrayLength: number): number[];
            (...items: number[]): number[];
            new (arrayLength: number): number[];
            new (...items: number[]): number[];
            isArray(arg: any): arg is any[];
            readonly prototype: any[];
            from<T>(arrayLike: ArrayLike<T>): T[];
            from<T_1, U>(arrayLike: ArrayLike<T_1>, mapfn: (v: T_1, k: number) => U, thisArg?: any): U[];
            from<T_2>(iterable: Iterable<T_2> | ArrayLike<T_2>): T_2[];
            from<T_3, U_1>(iterable: Iterable<T_3> | ArrayLike<T_3>, mapfn: (v: T_3, k: number) => U_1, thisArg?: any): U_1[];
            of<T_4>(...items: T_4[]): T_4[];
            readonly [Symbol.species]: ArrayConstructor;
        };
        default: () => number[];
    };
}, {
    simulation: Ref<ForceSimulation | null>;
}, unknown, {}, {}, ComponentOptionsMixin, ComponentOptionsMixin, ("node-click" | "node-double-click" | "node-context-menu" | "node-drag-start" | "node-drag-move" | "node-drag-end" | "link-click" | "link-double-click" | "link-context-menu" | "link-drag-start" | "link-drag-move" | "link-drag-end" | "environment-click" | "environment-double-click" | "environment-context-menu" | "environment-move" | "theme-change" | "simulation-tick" | "simulation-tick-end")[], "node-click" | "node-double-click" | "node-context-menu" | "node-drag-start" | "node-drag-move" | "node-drag-end" | "link-click" | "link-double-click" | "link-context-menu" | "link-drag-start" | "link-drag-move" | "link-drag-end" | "environment-click" | "environment-double-click" | "environment-context-menu" | "environment-move" | "theme-change" | "simulation-tick" | "simulation-tick-end", VNodeProps & AllowedComponentProps & ComponentCustomProps, Readonly<ExtractPropTypes<{
    dark: {
        type: BooleanConstructor;
        default: boolean;
    };
    remoteOrigin: {
        type: StringConstructor;
        default: string;
    };
    selectedNodes: {
        type: {
            (arrayLength: number): string[];
            (...items: string[]): string[];
            new (arrayLength: number): string[];
            new (...items: string[]): string[];
            isArray(arg: any): arg is any[];
            readonly prototype: any[];
            from<T>(arrayLike: ArrayLike<T>): T[];
            from<T_1, U>(arrayLike: ArrayLike<T_1>, mapfn: (v: T_1, k: number) => U, thisArg?: any): U[];
            from<T_2>(iterable: Iterable<T_2> | ArrayLike<T_2>): T_2[];
            from<T_3, U_1>(iterable: Iterable<T_3> | ArrayLike<T_3>, mapfn: (v: T_3, k: number) => U_1, thisArg?: any): U_1[];
            of<T_4>(...items: T_4[]): T_4[];
            readonly [Symbol.species]: ArrayConstructor;
        };
        default: () => never[];
    };
    envGravity: {
        type: NumberConstructor;
        default: number;
    };
    linkDistance: {
        type: NumberConstructor;
        default: number;
    };
    animationDuration: {
        type: NumberConstructor;
        default: number;
    };
    draggableNodes: {
        type: BooleanConstructor;
        default: boolean;
    };
    zoomEnabled: {
        type: BooleanConstructor;
        default: boolean;
    };
    zoomScaleExtent: {
        type: {
            (arrayLength: number): number[];
            (...items: number[]): number[];
            new (arrayLength: number): number[];
            new (...items: number[]): number[];
            isArray(arg: any): arg is any[];
            readonly prototype: any[];
            from<T>(arrayLike: ArrayLike<T>): T[];
            from<T_1, U>(arrayLike: ArrayLike<T_1>, mapfn: (v: T_1, k: number) => U, thisArg?: any): U[];
            from<T_2>(iterable: Iterable<T_2> | ArrayLike<T_2>): T_2[];
            from<T_3, U_1>(iterable: Iterable<T_3> | ArrayLike<T_3>, mapfn: (v: T_3, k: number) => U_1, thisArg?: any): U_1[];
            of<T_4>(...items: T_4[]): T_4[];
            readonly [Symbol.species]: ArrayConstructor;
        };
        default: () => number[];
    };
}>> & {
    "onNode-click"?: ((...args: any[]) => any) | undefined;
    "onNode-double-click"?: ((...args: any[]) => any) | undefined;
    "onNode-context-menu"?: ((...args: any[]) => any) | undefined;
    "onNode-drag-start"?: ((...args: any[]) => any) | undefined;
    "onNode-drag-move"?: ((...args: any[]) => any) | undefined;
    "onNode-drag-end"?: ((...args: any[]) => any) | undefined;
    "onLink-click"?: ((...args: any[]) => any) | undefined;
    "onLink-double-click"?: ((...args: any[]) => any) | undefined;
    "onLink-context-menu"?: ((...args: any[]) => any) | undefined;
    "onLink-drag-start"?: ((...args: any[]) => any) | undefined;
    "onLink-drag-move"?: ((...args: any[]) => any) | undefined;
    "onLink-drag-end"?: ((...args: any[]) => any) | undefined;
    "onEnvironment-click"?: ((...args: any[]) => any) | undefined;
    "onEnvironment-double-click"?: ((...args: any[]) => any) | undefined;
    "onEnvironment-context-menu"?: ((...args: any[]) => any) | undefined;
    "onEnvironment-move"?: ((...args: any[]) => any) | undefined;
    "onTheme-change"?: ((...args: any[]) => any) | undefined;
    "onSimulation-tick"?: ((...args: any[]) => any) | undefined;
    "onSimulation-tick-end"?: ((...args: any[]) => any) | undefined;
}, {
    dark: boolean;
    remoteOrigin: string;
    selectedNodes: string[];
    envGravity: number;
    linkDistance: number;
    animationDuration: number;
    draggableNodes: boolean;
    zoomEnabled: boolean;
    zoomScaleExtent: number[];
}>;
export default _default;

declare function EmitEvent(identifier: string, data: Node_2, event: any, ...args: any[]): void;

declare class EventStore {
    static readonly events: {
        [key: string]: {
            [key: string]: (...args: any[]) => void;
        };
    };
    private register;
    on(event: string, callback: (...args: any[]) => void): void;
    off(event: string, callback: (...args: any[]) => void): void;
    emit(event: string, ...args: any[]): any;
}

declare interface ExportGraph {
    nodes: ExportNode[];
    links: ExportLink[];
}

declare interface ExportLink {
    source: string;
    target: string;
    id?: string;
    type?: string;
    directed?: boolean | string;
    label?: string;
    strength?: number | string;
    padding?: number;
    width?: number;
    curvature?: number;
    payload?: any;
}

declare interface ExportNode {
    id: string;
    x?: number;
    y?: number;
    shape: {
        type: string;
        scale: number;
        url?: string;
    };
    gravity?: number;
    anchor?: {
        type: string;
        x: number;
        y: number;
    };
    satellite?: {
        source: string;
        angle: number;
        distance: number;
    };
    payload?: any;
}

declare class ForceSimulation {
    debug: {
        enabled: boolean;
        bodyPoints: {
            enabled: boolean;
            color: string;
        };
    };
    private _svgElement;
    get svgElement(): SVGElement;
    set svgElement(svgElement: SVGElement);
    private _svgSelection;
    get svgSelection(): d3_2.Selection<SVGElement, any, any, any>;
    private _simulation;
    get simulation(): d3_2.Simulation<Node_2, Link>;
    private _selectedNodes;
    get selectedNodes(): string[];
    set selectedNodes(ids: string[]);
    private _zoom;
    worldTransform: {
        x: number;
        y: number;
        k: number;
    };
    get worldBounds(): Boundary;
    set zoomScaleExtent(extent: [number, number]);
    set zoomEnabled(enabled: boolean);
    private _onZoomRegister;
    get onZoomRegister(): {
        id: string;
        threshold: number;
        callback: (k: number) => boolean;
    }[];
    private _onZoomRoutines;
    get onZoomRoutines(): {
        [threshold: number]: ((k: number) => boolean)[];
    };
    set envGravity(value: number);
    set linkDistance(value: number);
    animationDuration: number;
    draggableNodes: boolean;
    selectionGroups: SelectionGroups;
    graph: Graph;
    templateStore: TemplateStore;
    nodeDataStore: NodeDataStore;
    readonly eventStore: EventStore;
    constructor(svgEl: SVGElement | d3_2.Selection<SVGElement, any, any, any>);
    private createSimulation;
    private createWorld;
    private setEvents;
    theme: "light" | "dark";
    private themeChangeObserver;
    registerOnZoom(id: string, threshold: number, callback: (k: number) => boolean): void;
    deregisterOnZoom(id: string): void;
    private selectNodes;
    render(this: ForceSimulation, graph: Graph, alpha?: number, forced?: boolean): Promise<void>;
    snapshot(ticks?: number): SVGElement;
    exportGraph(): ExportGraph;
    moveTo(options: MoveOptions): void;
    on(event: string, callback: (...args: any[]) => void): void;
}

declare function getBBox(shape: d3_2.Selection<SVGElement, any, any, any>): SVGRect;

declare interface Graph {
    nodes: Node_2[];
    links: Link[];
}

declare function isDark(color: string): boolean;

declare function isLight(color: string): boolean;

declare interface Link extends D3Link {
    id?: string;
    type?: LinkType | "solid" | "dashed" | "dotted" | "hidden";
    directed?: boolean | ArrowDirection | "head" | "tail" | "both";
    label?: string;
    strength?: number | LinkStrength | "strong" | "weak" | "loose";
    padding?: number;
    width?: number;
    curvature?: number;
    color?: string;
    payload?: any;
}

declare enum LinkStrength {
    Strong = "strong",
    Weak = "weak",
    Loose = "loose"
}

declare enum LinkType {
    Solid = "solid",
    Dashed = "dashed",
    Dotted = "dotted",
    Hidden = "hidden"
}

declare function LODStyle(shape: d3_2.Selection<any, any, any, any>, key: string, value: string, condition?: ((k: number) => boolean) | boolean): LODStyle;

declare interface LODStyle {
    shape: d3_2.Selection<any, any, any, any>;
    key: string;
    value: string;
    condition: ((k: number) => boolean) | boolean;
}

declare interface MoveOptions {
    transform?: Transform;
    boundaries?: Boundary[];
    nodes?: Node_2[];
    duration?: number;
    padding?: number;
}

declare type Node_2<T = any> = D3Node & {
    shape: Shape;
    renderConfig?: RenderConfig;
    forceSimulation?: ForceSimulation;
    gravity?: number;
    spawn?: Spawn;
    anchor?: Anchor;
    satellite?: Satellite;
    errorMessage?: string;
    payload?: T;
};

declare class NodeDataStore {
    private nodes;
    clear(): void;
    add(id: string, node: Node_2): void;
    remove(id: string): void;
    hasNode(id: string): boolean;
    hasTemplateChange(id: string, data: Node_2): boolean;
    hasPayloadChanges(id: string, data: Node_2): boolean;
    private storeNode;
    private deepCopy;
}

declare function OnThemeChange(data: Node_2, callback: (theme: "light" | "dark") => void): void;

declare function OnZoom(data: Node_2, threshold: number | number[], styles?: LODStyle[]): void;

declare function PathShape(path: string): d3.Selection<SVGElement, any, any, any>;

declare function Polygon(n: number, radius: number, curveRadius?: number): d3_2.Selection<SVGElement, any, any, any>;

declare function prerender(shape: d3_2.Selection<SVGElement, any, any, any>, onElement: (el: SVGGraphicsElement) => void): void;

declare function Rectangle(width: number, height: number, cr?: number): d3_2.Selection<SVGElement, any, any, any>;

declare type RenderConfig = {
    theme: "light" | "dark";
    scale: number;
};

declare type Satellite = {
    x?: number;
    y?: number;
    type?: SatelliteType | "soft" | "hard";
    source: string | Node_2;
    angle: number;
    distance: number;
};

declare enum SatelliteType {
    Soft = "soft",
    Hard = "hard"
}

declare interface SelectionGroups {
    world: d3_2.Selection<SVGGElement, any, any, any>;
    nodes: d3_2.Selection<SVGGElement, any, any, any>;
    links: d3_2.Selection<SVGGElement, any, any, any>;
}

declare type Shape = {
    type: string;
    scale: number;
    url?: string;
    template?: Template;
    bodyPoints?: {
        x: number;
        y: number;
    }[];
    bodyResolution?: number;
    failed?: boolean;
};

declare namespace Shape_2 {
    export {
        prerender,
        getBBox,
        create,
        transform,
        Circle,
        Rectangle,
        Polygon
    }
}

declare function ShapeCollection(shapes: (d3_2.Selection<SVGElement, any, any, any> | BreakLine)[], style: CollectionStyle, ellipsis?: d3_2.Selection<SVGElement, any, any, any> | null): d3_2.Selection<SVGElement, any, any, any>;

declare function ShapeStyle(key: string, value: string | ThemeStyle, condition?: (() => boolean) | boolean): ShapeStyle;

declare interface ShapeStyle {
    key: string;
    value: string | ThemeStyle;
    condition: (() => boolean) | boolean;
}

declare type Spawn = {
    source: string | Node_2;
    angle: number;
    distance: number;
};

declare function SVGShape(code: string): d3.Selection<SVGElement, any, any, any>;

declare function TagCollection(tags: string[], style: CollectionStyle, tagStyle: TagStyle): d3_2.Selection<SVGElement, any, any, any>;

declare function TagShape(text: string, style: TagStyle): d3_2.Selection<SVGElement, any, any, any>;

declare function TagStyle(padding: number | [number, number] | [number, number, number, number], textStyles?: ShapeStyle[], backgroundStyles?: ShapeStyle[], cornerRadius?: number): TagStyle;

declare interface TagStyle {
    padding: {
        top: number;
        right: number;
        bottom: number;
        left: number;
    };
    textStyles: ShapeStyle[];
    backgroundStyles: ShapeStyle[];
    cornerRadius: number;
}

declare namespace TAPI {
    export {
        Shape_2 as Shape,
        ThemeStyle,
        ShapeStyle,
        LODStyle,
        applyStyles,
        applyLODStyles,
        PathShape,
        SVGShape,
        TagStyle,
        TagShape,
        TextShape,
        BreakLine,
        CollectionStyle,
        ShapeCollection,
        Alignment,
        TextCollection,
        TagCollection,
        OnZoom,
        OnThemeChange,
        brightness,
        isLight,
        isDark,
        EmitEvent
    }
}

declare interface Template<T = any> {
    shapeSize: number;
    shapePayload?: T;
    shapeBuilder: (data: Node_2<T>, TemplateAPI: typeof TAPI) => d3_2.Selection<any, any, any, any>;
}

declare class TemplateStore {
    private _errorTemplate;
    get errorTemplate(): Template;
    private _templates;
    get templates(): {
        [key: string]: Template;
    };
    private failed;
    remoteOrigin: string;
    add(id: string, template: Template): void;
    get(node: Node_2): Promise<Template | undefined>;
    private load;
}

declare function TextCollection(text: string, style: CollectionStyle, textStyles?: ShapeStyle[]): d3_2.Selection<SVGElement, any, any, any>;

/**
 * @param  {String} text
 * @param  {ShapeStyle[]} styles
 * @return {Object} shape
 */
declare function TextShape(text: string, styles?: ShapeStyle[]): d3.Selection<SVGElement, any, any, any>;

declare function ThemeStyle(data: Node_2, lightValue: string, darkValue: string): ThemeStyle;

declare interface ThemeStyle {
    data: Node_2;
    lightValue: string;
    darkValue: string;
}

declare interface Transform {
    x: number;
    y: number;
    k: number;
}

declare function transform(shape: d3_2.Selection<SVGElement, any, any, any>, size: number): {
    scale: number;
    translate: {
        x: number;
        y: number;
    };
};

export { }
